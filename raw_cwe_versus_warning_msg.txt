CWE121_Stack_Based_Buffer_Overflow	accessing out of bounds index. assert data_0 < 10;
CWE121_Stack_Based_Buffer_Overflow	accessing out of bounds index. assert data < 10;
CWE121_Stack_Based_Buffer_Overflow	accessing out of bounds index. assert data_1 < 10;
CWE121_Stack_Based_Buffer_Overflow	accessing out of bounds index. assert i_0 < 50;
CWE121_Stack_Based_Buffer_Overflow	accessing out of bounds index. assert i < 50;
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(&data);
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(data + 0);
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(data_0 + 0);
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(data_0 + i);
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(data_1 + i);
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(data + i);
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(data + i_0);
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(dataPtr1);
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(&source[i]);
CWE121_Stack_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(&source[i_0]);
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE121_Stack_Based_Buffer_Overflow	all target addresses were invalid. This path is assumed to be dead.
CWE121_Stack_Based_Buffer_Overflow	Array access (from variable 'data') results in a null pointer dereference
CWE121_Stack_Based_Buffer_Overflow	Array 'buffer[10]' accessed at index 10, which is out of bounds.
CWE121_Stack_Based_Buffer_Overflow	Array 'dataBadBuffer[10]' accessed at index 10, which is out of bounds.
CWE121_Stack_Based_Buffer_Overflow	Array 'dataBadBuffer[50]' accessed at index 99, which is out of bounds.
CWE121_Stack_Based_Buffer_Overflow	Assigned value is garbage or undefined
CWE121_Stack_Based_Buffer_Overflow	Calling undeclared function alloca. Old style K&R code?
CWE121_Stack_Based_Buffer_Overflow	Completely invalid destination for assigns
CWE121_Stack_Based_Buffer_Overflow	Condition '5!=5' is always false
CWE121_Stack_Based_Buffer_Overflow	Condition '5==5' is always true
CWE121_Stack_Based_Buffer_Overflow	Condition 'data>=0' is always true
CWE121_Stack_Based_Buffer_Overflow	Dereference of undefined pointer value
CWE121_Stack_Based_Buffer_Overflow	Does not check for buffer overflows when concatenating to destination (CWE-120). Consider using strcat_s, strncat, or strlcat (warning, strncat is easily misused).
CWE121_Stack_Based_Buffer_Overflow	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused).
CWE121_Stack_Based_Buffer_Overflow	Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
CWE121_Stack_Based_Buffer_Overflow	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE121_Stack_Based_Buffer_Overflow	Easily used incorrectly; doesn't always \0-terminate or check for invalid pointers (CWE-120).
CWE121_Stack_Based_Buffer_Overflow	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE121_Stack_Based_Buffer_Overflow	Function call argument is an uninitialized value
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_45_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68_goodG2BData
CWE121_Stack_Based_Buffer_Overflow	Neither code nor specification for function alloca, generating default assigns from the prototype
CWE121_Stack_Based_Buffer_Overflow	Neither code nor specification for function connect, generating default assigns from the prototype
CWE121_Stack_Based_Buffer_Overflow	No code nor implicit assigns clause for function calloc, generating default assigns from the prototype
CWE121_Stack_Based_Buffer_Overflow	Null pointer passed as an argument to a 'nonnull' parameter
CWE121_Stack_Based_Buffer_Overflow	out of bounds write. assert \valid(data + 0);
CWE121_Stack_Based_Buffer_Overflow	out of bounds write. assert \valid(data_0 + i);
CWE121_Stack_Based_Buffer_Overflow	out of bounds write. assert \valid(data_0 + i_0);
CWE121_Stack_Based_Buffer_Overflow	out of bounds write. assert \valid(data_1 + i);
CWE121_Stack_Based_Buffer_Overflow	out of bounds write. assert \valid(data + i);
CWE121_Stack_Based_Buffer_Overflow	out of bounds write. assert \valid(data + i_0);
CWE121_Stack_Based_Buffer_Overflow	out of bounds write. assert \valid(data + (int)(100 - 1));
CWE121_Stack_Based_Buffer_Overflow	Possible null pointer dereference: data
CWE121_Stack_Based_Buffer_Overflow	Same expression on both sides of '=='.
CWE121_Stack_Based_Buffer_Overflow	Same expression on both sides of '!='.
CWE121_Stack_Based_Buffer_Overflow	signed overflow. assert tmp_2 << 30 ≤ 2147483647;
CWE121_Stack_Based_Buffer_Overflow	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE121_Stack_Based_Buffer_Overflow	Size argument is greater than the free space in the destination buffer
CWE121_Stack_Based_Buffer_Overflow	Size argument is greater than the length of the destination buffer
CWE121_Stack_Based_Buffer_Overflow	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE121_Stack_Based_Buffer_Overflow	String copy function overflows destination buffer
CWE121_Stack_Based_Buffer_Overflow	The scope of the variable 'buffer' can be reduced.
CWE121_Stack_Based_Buffer_Overflow	The scope of the variable 'dataRef' can be reduced.
CWE121_Stack_Based_Buffer_Overflow	The scope of the variable 'i' can be reduced.
CWE121_Stack_Based_Buffer_Overflow	The scope of the variable 'recvResult' can be reduced.
CWE121_Stack_Based_Buffer_Overflow	Uninitialized variable: data
CWE121_Stack_Based_Buffer_Overflow	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE121_Stack_Based_Buffer_Overflow	Unused variable: dataBadBuffer
CWE121_Stack_Based_Buffer_Overflow	Unused variable: dataBuffer
CWE121_Stack_Based_Buffer_Overflow	Unused variable: dataGoodBuffer
CWE121_Stack_Based_Buffer_Overflow	Value stored to 'dataBadBuffer' during its initialization is never read
CWE121_Stack_Based_Buffer_Overflow	Value stored to 'data' during its initialization is never read
CWE121_Stack_Based_Buffer_Overflow	Value stored to 'dataGoodBuffer' during its initialization is never read
CWE121_Stack_Based_Buffer_Overflow	Value stored to 'data' is never read
CWE121_Stack_Based_Buffer_Overflow	Variable 'dataBadBuffer' is assigned a value that is never used.
CWE121_Stack_Based_Buffer_Overflow	Variable 'dataGoodBuffer' is assigned a value that is never used.
CWE121_Stack_Based_Buffer_Overflow	Variable 'data' is assigned a value that is never used.
CWE121_Stack_Based_Buffer_Overflow	Variable 'data' is not assigned a value.
CWE121_Stack_Based_Buffer_Overflow	Variable 'data' is reassigned a value before the old one has been used.
CWE121_Stack_Based_Buffer_Overflow	Variable 'dest' is assigned a value that is never used.
CWE122_Heap_Based_Buffer_Overflow	accessing out of bounds index. assert i_0 < 50;
CWE122_Heap_Based_Buffer_Overflow	accessing out of bounds index. assert i_0 < (int)(10 + 1);
CWE122_Heap_Based_Buffer_Overflow	accessing out of bounds index. assert i < 50;
CWE122_Heap_Based_Buffer_Overflow	accessing out of bounds index. assert i < (int)(10 + 1);
CWE122_Heap_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(&source[i]);
CWE122_Heap_Based_Buffer_Overflow	accessing uninitialized left-value. assert \initialized(&source[i_0]);
CWE122_Heap_Based_Buffer_Overflow	Array '[50]' accessed at index 99, which is out of bounds.
CWE122_Heap_Based_Buffer_Overflow	Array access (from variable 'data') results in a null pointer dereference
CWE122_Heap_Based_Buffer_Overflow	Array 'buffer[10]' accessed at index 10, which is out of bounds.
CWE122_Heap_Based_Buffer_Overflow	Array 'data[10]' accessed at index 10, which is out of bounds.
CWE122_Heap_Based_Buffer_Overflow	Array 'data[2]' accessed at index 9, which is out of bounds.
CWE122_Heap_Based_Buffer_Overflow	Array 'data[50]' accessed at index 99, which is out of bounds.
CWE122_Heap_Based_Buffer_Overflow	Assigned value is garbage or undefined
CWE122_Heap_Based_Buffer_Overflow	Buffer is accessed out of bounds.
CWE122_Heap_Based_Buffer_Overflow	Completely invalid destination for assigns
CWE122_Heap_Based_Buffer_Overflow	Condition '5!=5' is always false
CWE122_Heap_Based_Buffer_Overflow	Condition '5==5' is always true
CWE122_Heap_Based_Buffer_Overflow	Condition 'data>=0' is always true
CWE122_Heap_Based_Buffer_Overflow	Dereference of null pointer (loaded from variable 'data')
CWE122_Heap_Based_Buffer_Overflow	Does not check for buffer overflows when concatenating to destination (CWE-120). Consider using strcat_s, strncat, or strlcat (warning, strncat is easily misused).
CWE122_Heap_Based_Buffer_Overflow	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused).
CWE122_Heap_Based_Buffer_Overflow	Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
CWE122_Heap_Based_Buffer_Overflow	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE122_Heap_Based_Buffer_Overflow	Easily used incorrectly; doesn't always \0-terminate or check for invalid pointers (CWE-120).
CWE122_Heap_Based_Buffer_Overflow	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE122_Heap_Based_Buffer_Overflow	Floating-point constant 1.7E300 is not represented exactly. Will use 0x1.44ecd0d33972bp997. See documentation for option -warn-decimal-float
CWE122_Heap_Based_Buffer_Overflow	Memory is allocated but not initialized: data
CWE122_Heap_Based_Buffer_Overflow	Memory leak: data
CWE122_Heap_Based_Buffer_Overflow	Memory leak: dataBadBuffer
CWE122_Heap_Based_Buffer_Overflow	Memory leak: dataGoodBuffer
CWE122_Heap_Based_Buffer_Overflow	Neither code nor specification for function connect, generating default assigns from the prototype
CWE122_Heap_Based_Buffer_Overflow	No code nor implicit assigns clause for function calloc, generating default assigns from the prototype
CWE122_Heap_Based_Buffer_Overflow	non-finite double value. assert \is_finite(*data);
CWE122_Heap_Based_Buffer_Overflow	non-finite double value. assert \is_finite(*data_0);
CWE122_Heap_Based_Buffer_Overflow	non-finite double value. assert \is_finite(*data_1);
CWE122_Heap_Based_Buffer_Overflow	Null pointer passed as an argument to a 'nonnull' parameter
CWE122_Heap_Based_Buffer_Overflow	out of bounds read. assert \valid_read(data);
CWE122_Heap_Based_Buffer_Overflow	out of bounds read. assert \valid_read(data + 0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds read. assert \valid_read(data_0 + 0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds read. assert \valid_read(data_1 + 0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds read. assert \valid_read(data + i);
CWE122_Heap_Based_Buffer_Overflow	out of bounds read. assert \valid_read(data + i_0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(buffer_0 + data);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(buffer_0 + i_0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(buffer + data);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(buffer + data_0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(buffer + data_1);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(buffer + i);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(buffer + i_0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data + 0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data_0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data_0 + 0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data_0 + i);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data_0 + i_0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data_0 + (int)(100 - 1));
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data_0 + (int)(50 - 1));
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(&data_0->intOne);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data_1 + i);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data_1 + i_0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(dataBadBuffer_0 + (int)(50 - 1));
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(dataBadBuffer + (int)(50 - 1));
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(dataGoodBuffer_0 + (int)(50 - 1));
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(dataGoodBuffer + (int)(50 - 1));
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data + i);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data + i_0);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data + i_1);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data + (int)(100 - 1));
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(data + (int)(50 - 1));
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(&data->intOne);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(&structCharVoid_0->voidSecond);
CWE122_Heap_Based_Buffer_Overflow	out of bounds write. assert \valid(&structCharVoid->voidSecond);
CWE122_Heap_Based_Buffer_Overflow	pointer comparison. assert \pointer_comparable((void *)i_0, (void *)dataLen);
CWE122_Heap_Based_Buffer_Overflow	pointer comparison. assert \pointer_comparable((void *)i, (void *)dataLen);
CWE122_Heap_Based_Buffer_Overflow	Possible null pointer dereference: data
CWE122_Heap_Based_Buffer_Overflow	Potential leak of memory pointed to by 'data'
CWE122_Heap_Based_Buffer_Overflow	Potential leak of memory pointed to by 'dataBadBuffer'
CWE122_Heap_Based_Buffer_Overflow	Potential leak of memory pointed to by 'dataGoodBuffer'
CWE122_Heap_Based_Buffer_Overflow	Potential leak of memory pointed to by 'myUnion.unionFirst'
CWE122_Heap_Based_Buffer_Overflow	Potential leak of memory pointed to by 'structCharVoid'
CWE122_Heap_Based_Buffer_Overflow	Result of 'malloc' is converted to a pointer of type 'char', which is incompatible with sizeof operand type 'class OneIntClass'
CWE122_Heap_Based_Buffer_Overflow	Result of 'malloc' is converted to a pointer of type 'char', which is incompatible with sizeof operand type 'class TwoIntsClass'
CWE122_Heap_Based_Buffer_Overflow	Result of 'malloc' is converted to a pointer of type 'double', which is incompatible with sizeof operand type 'double *'
CWE122_Heap_Based_Buffer_Overflow	Result of 'malloc' is converted to a pointer of type 'int64_t', which is incompatible with sizeof operand type 'int64_t *'
CWE122_Heap_Based_Buffer_Overflow	Result of 'malloc' is converted to a pointer of type 'twoIntsStruct', which is incompatible with sizeof operand type 'twoIntsStruct *'
CWE122_Heap_Based_Buffer_Overflow	Same expression on both sides of '=='.
CWE122_Heap_Based_Buffer_Overflow	Same expression on both sides of '!='.
CWE122_Heap_Based_Buffer_Overflow	signed overflow. assert tmp_2 << 30 ≤ 2147483647;
CWE122_Heap_Based_Buffer_Overflow	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE122_Heap_Based_Buffer_Overflow	Size argument is greater than the free space in the destination buffer
CWE122_Heap_Based_Buffer_Overflow	Size argument is greater than the length of the destination buffer
CWE122_Heap_Based_Buffer_Overflow	Size of pointer 'data' used instead of size of its data.
CWE122_Heap_Based_Buffer_Overflow	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE122_Heap_Based_Buffer_Overflow	String copy function overflows destination buffer
CWE122_Heap_Based_Buffer_Overflow	The allocated size 10 is not a multiple of the underlying type's size.
CWE122_Heap_Based_Buffer_Overflow	The scope of the variable 'dataRef' can be reduced.
CWE122_Heap_Based_Buffer_Overflow	The scope of the variable 'recvResult' can be reduced.
CWE122_Heap_Based_Buffer_Overflow	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE122_Heap_Based_Buffer_Overflow	Value stored to 'dataBadBuffer' during its initialization is never read
CWE122_Heap_Based_Buffer_Overflow	Value stored to 'data' during its initialization is never read
CWE122_Heap_Based_Buffer_Overflow	Value stored to 'dataGoodBuffer' during its initialization is never read
CWE122_Heap_Based_Buffer_Overflow	Value stored to 'data' is never read
CWE122_Heap_Based_Buffer_Overflow	Variable 'dataBadBuffer' is assigned a value that is never used.
CWE122_Heap_Based_Buffer_Overflow	Variable 'dataGoodBuffer' is assigned a value that is never used.
CWE122_Heap_Based_Buffer_Overflow	Variable 'data' is assigned a value that is never used.
CWE122_Heap_Based_Buffer_Overflow	Variable 'data' is not assigned a value.
CWE122_Heap_Based_Buffer_Overflow	Variable 'data' is reassigned a value before the old one has been used.
CWE122_Heap_Based_Buffer_Overflow	Variable 'dest' is assigned a value that is never used.
CWE123_Write_What_Where_Condition	Address of stack memory associated with local variable 'head' is still referred to by the global variable 'linkedListNext' upon returning to the caller.  This will be a dangling reference
CWE123_Write_What_Where_Condition	Address of stack memory associated with local variable 'head' is still referred to by the global variable 'linkedListPrev' upon returning to the caller.  This will be a dangling reference
CWE123_Write_What_Where_Condition	Completely invalid destination for assigns
CWE123_Write_What_Where_Condition	Condition '5!=5' is always false
CWE123_Write_What_Where_Condition	Condition '5==5' is always true
CWE123_Write_What_Where_Condition	Function parameter 'dataCopy' should be passed by reference.
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B1 through linkedListNext
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B1 through linkedListPrev
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B2 through linkedListNext
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B2 through linkedListPrev
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B through CWE123_Write_What_Where_Condition__connect_socket_45_goodG2BData
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B through CWE123_Write_What_Where_Condition__connect_socket_68_goodG2BData
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B through CWE123_Write_What_Where_Condition__fgets_45_goodG2BData
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B through CWE123_Write_What_Where_Condition__fgets_68_goodG2BData
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B through CWE123_Write_What_Where_Condition__listen_socket_45_goodG2BData
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B through CWE123_Write_What_Where_Condition__listen_socket_68_goodG2BData
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B through linkedListNext
CWE123_Write_What_Where_Condition	locals {head} escaping the scope of goodG2B through linkedListPrev
CWE123_Write_What_Where_Condition	Neither code nor specification for function connect, generating default assigns from the prototype
CWE123_Write_What_Where_Condition	out of bounds write. assert \valid(&linkedListNext->prev);
CWE123_Write_What_Where_Condition	out of bounds write. assert \valid(&linkedListPrev->next);
CWE123_Write_What_Where_Condition	Same expression on both sides of '=='.
CWE123_Write_What_Where_Condition	Same expression on both sides of '!='.
CWE123_Write_What_Where_Condition	The scope of the variable 'recvResult' can be reduced.
CWE123_Write_What_Where_Condition	Variable 'data' is assigned in constructor body. Consider performing initialization in initialization list.
CWE124_Buffer_Underwrite	accessing out of bounds index. assert 0 ≤ data;
CWE124_Buffer_Underwrite	accessing out of bounds index. assert 0 ≤ data_0;
CWE124_Buffer_Underwrite	accessing out of bounds index. assert 0 ≤ data_1;
CWE124_Buffer_Underwrite	accessing out of bounds index. assert data_0 < 10;
CWE124_Buffer_Underwrite	accessing out of bounds index. assert data < 10;
CWE124_Buffer_Underwrite	accessing out of bounds index. assert data_1 < 10;
CWE124_Buffer_Underwrite	accessing uninitialized left-value. assert \initialized(&data);
CWE124_Buffer_Underwrite	accessing uninitialized left-value. assert \initialized(dataPtr1);
CWE124_Buffer_Underwrite	accessing uninitialized left-value. assert \initialized(&source[i]);
CWE124_Buffer_Underwrite	accessing uninitialized left-value. assert \initialized(&source[i_0]);
CWE124_Buffer_Underwrite	all target addresses were invalid. This path is assumed to be dead.
CWE124_Buffer_Underwrite	Array access (from variable 'data') results in a null pointer dereference
CWE124_Buffer_Underwrite	Array index -5 is out of bounds.
CWE124_Buffer_Underwrite	Assigned value is garbage or undefined
CWE124_Buffer_Underwrite	Calling undeclared function alloca. Old style K&R code?
CWE124_Buffer_Underwrite	Completely invalid destination for assigns
CWE124_Buffer_Underwrite	Condition '5!=5' is always false
CWE124_Buffer_Underwrite	Condition '5==5' is always true
CWE124_Buffer_Underwrite	Condition 'data>=0' is always false
CWE124_Buffer_Underwrite	Condition 'data<10' is always true
CWE124_Buffer_Underwrite	Dereference of undefined pointer value
CWE124_Buffer_Underwrite	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused).
CWE124_Buffer_Underwrite	Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
CWE124_Buffer_Underwrite	Easily used incorrectly; doesn't always \0-terminate or check for invalid pointers (CWE-120).
CWE124_Buffer_Underwrite	Function call argument is an uninitialized value
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_cpy_45_goodG2BData
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_cpy_68_goodG2BData
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_loop_45_goodG2BData
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_loop_68_goodG2BData
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_memcpy_45_goodG2BData
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_memcpy_68_goodG2BData
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_memmove_45_goodG2BData
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_memmove_68_goodG2BData
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_ncpy_45_goodG2BData
CWE124_Buffer_Underwrite	locals {dataBuffer} escaping the scope of goodG2B through CWE124_Buffer_Underwrite__char_declare_ncpy_68_goodG2BData
CWE124_Buffer_Underwrite	Memory leak: dataBuffer
CWE124_Buffer_Underwrite	Neither code nor specification for function alloca, generating default assigns from the prototype
CWE124_Buffer_Underwrite	Neither code nor specification for function connect, generating default assigns from the prototype
CWE124_Buffer_Underwrite	Null pointer passed as an argument to a 'nonnull' parameter
CWE124_Buffer_Underwrite	out of bounds write. assert \valid(data_0 + i);
CWE124_Buffer_Underwrite	out of bounds write. assert \valid(data_1 + i);
CWE124_Buffer_Underwrite	out of bounds write. assert \valid(dataBuffer_0 + (int)(100 - 1));
CWE124_Buffer_Underwrite	out of bounds write. assert \valid(dataBuffer + (int)(100 - 1));
CWE124_Buffer_Underwrite	out of bounds write. assert \valid(data + i);
CWE124_Buffer_Underwrite	out of bounds write. assert \valid(data + i_0);
CWE124_Buffer_Underwrite	out of bounds write. assert \valid(data + (int)(100 - 1));
CWE124_Buffer_Underwrite	Possible null pointer dereference: data
CWE124_Buffer_Underwrite	Same expression on both sides of '=='.
CWE124_Buffer_Underwrite	Same expression on both sides of '!='.
CWE124_Buffer_Underwrite	signed overflow. assert tmp_2 << 30 ≤ 2147483647;
CWE124_Buffer_Underwrite	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE124_Buffer_Underwrite	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE124_Buffer_Underwrite	The scope of the variable 'buffer' can be reduced.
CWE124_Buffer_Underwrite	The scope of the variable 'dataRef' can be reduced.
CWE124_Buffer_Underwrite	The scope of the variable 'i' can be reduced.
CWE124_Buffer_Underwrite	The scope of the variable 'recvResult' can be reduced.
CWE124_Buffer_Underwrite	Undefined behaviour, pointer arithmetic 'dataBuffer-8' is out of bounds.
CWE124_Buffer_Underwrite	Uninitialized variable: data
CWE124_Buffer_Underwrite	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE124_Buffer_Underwrite	Value stored to 'data' during its initialization is never read
CWE124_Buffer_Underwrite	Value stored to 'data' is never read
CWE124_Buffer_Underwrite	Variable 'dataBuffer' is assigned a value that is never used.
CWE124_Buffer_Underwrite	Variable 'data' is assigned a value that is never used.
CWE124_Buffer_Underwrite	Variable 'data' is not assigned a value.
CWE124_Buffer_Underwrite	Variable 'data' is reassigned a value before the old one has been used.
CWE126_Buffer_Overread	accessing out of bounds index. assert data_0 < 10;
CWE126_Buffer_Overread	accessing out of bounds index. assert data < 10;
CWE126_Buffer_Overread	accessing out of bounds index. assert data_1 < 10;
CWE126_Buffer_Overread	accessing out of bounds index. assert i_0 < 100;
CWE126_Buffer_Overread	accessing out of bounds index. assert i < 100;
CWE126_Buffer_Overread	accessing uninitialized left-value. assert \initialized(&data);
CWE126_Buffer_Overread	accessing uninitialized left-value. assert \initialized(data_0 + i);
CWE126_Buffer_Overread	accessing uninitialized left-value. assert \initialized(data + i);
CWE126_Buffer_Overread	accessing uninitialized left-value. assert \initialized(data + i_0);
CWE126_Buffer_Overread	accessing uninitialized left-value. assert \initialized(dataPtr1);
CWE126_Buffer_Overread	accessing uninitialized left-value. assert \initialized(&src_0[i_0]);
CWE126_Buffer_Overread	accessing uninitialized left-value. assert \initialized(&src[i]);
CWE126_Buffer_Overread	Array access (from variable 'data') results in a null pointer dereference
CWE126_Buffer_Overread	Array 'buffer[10]' accessed at index 10, which is out of bounds.
CWE126_Buffer_Overread	Assigned value is garbage or undefined
CWE126_Buffer_Overread	Calling undeclared function alloca. Old style K&R code?
CWE126_Buffer_Overread	Completely invalid destination for assigns
CWE126_Buffer_Overread	Condition '5!=5' is always false
CWE126_Buffer_Overread	Condition '5==5' is always true
CWE126_Buffer_Overread	Condition 'data>=0' is always true
CWE126_Buffer_Overread	Dereference of undefined pointer value
CWE126_Buffer_Overread	Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
CWE126_Buffer_Overread	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE126_Buffer_Overread	Easily used incorrectly; doesn't always \0-terminate or check for invalid pointers (CWE-120).
CWE126_Buffer_Overread	Function call argument is an uninitialized value
CWE126_Buffer_Overread	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE126_Buffer_Overread__char_declare_loop_45_goodG2BData
CWE126_Buffer_Overread	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE126_Buffer_Overread__char_declare_loop_68_goodG2BData
CWE126_Buffer_Overread	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE126_Buffer_Overread__char_declare_memcpy_45_goodG2BData
CWE126_Buffer_Overread	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE126_Buffer_Overread__char_declare_memcpy_68_goodG2BData
CWE126_Buffer_Overread	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE126_Buffer_Overread__char_declare_memmove_45_goodG2BData
CWE126_Buffer_Overread	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE126_Buffer_Overread__char_declare_memmove_68_goodG2BData
CWE126_Buffer_Overread	Neither code nor specification for function alloca, generating default assigns from the prototype
CWE126_Buffer_Overread	Neither code nor specification for function connect, generating default assigns from the prototype
CWE126_Buffer_Overread	Null pointer passed as an argument to a 'nonnull' parameter
CWE126_Buffer_Overread	out of bounds read. assert \valid_read(data_0 + i);
CWE126_Buffer_Overread	out of bounds read. assert \valid_read(data + i);
CWE126_Buffer_Overread	out of bounds read. assert \valid_read(data + i_0);
CWE126_Buffer_Overread	out of bounds write. assert \valid(data_0 + (int)(100 - 1));
CWE126_Buffer_Overread	out of bounds write. assert \valid(data_0 + (int)(50 - 1));
CWE126_Buffer_Overread	out of bounds write. assert \valid(data + (int)(100 - 1));
CWE126_Buffer_Overread	out of bounds write. assert \valid(data + (int)(50 - 1));
CWE126_Buffer_Overread	Possible null pointer dereference: data
CWE126_Buffer_Overread	Same expression on both sides of '=='.
CWE126_Buffer_Overread	Same expression on both sides of '!='.
CWE126_Buffer_Overread	signed overflow. assert tmp_2 << 30 ≤ 2147483647;
CWE126_Buffer_Overread	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE126_Buffer_Overread	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE126_Buffer_Overread	The scope of the variable 'buffer' can be reduced.
CWE126_Buffer_Overread	The scope of the variable 'dataRef' can be reduced.
CWE126_Buffer_Overread	The scope of the variable 'recvResult' can be reduced.
CWE126_Buffer_Overread	Uninitialized variable: data
CWE126_Buffer_Overread	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE126_Buffer_Overread	Value stored to 'data' during its initialization is never read
CWE126_Buffer_Overread	Value stored to 'data' is never read
CWE126_Buffer_Overread	Variable 'dataBadBuffer' is assigned a value that is never used.
CWE126_Buffer_Overread	Variable 'dataGoodBuffer' is assigned a value that is never used.
CWE126_Buffer_Overread	Variable 'data' is assigned a value that is never used.
CWE126_Buffer_Overread	Variable 'data' is not assigned a value.
CWE126_Buffer_Overread	Variable 'data' is reassigned a value before the old one has been used.
CWE127_Buffer_Underread	accessing out of bounds index. assert 0 ≤ data;
CWE127_Buffer_Underread	accessing out of bounds index. assert 0 ≤ data_0;
CWE127_Buffer_Underread	accessing out of bounds index. assert 0 ≤ data_1;
CWE127_Buffer_Underread	accessing out of bounds index. assert data_0 < 10;
CWE127_Buffer_Underread	accessing out of bounds index. assert data < 10;
CWE127_Buffer_Underread	accessing out of bounds index. assert data_1 < 10;
CWE127_Buffer_Underread	accessing uninitialized left-value. assert \initialized(&data);
CWE127_Buffer_Underread	accessing uninitialized left-value. assert \initialized(data_0 + i);
CWE127_Buffer_Underread	accessing uninitialized left-value. assert \initialized(data + i);
CWE127_Buffer_Underread	accessing uninitialized left-value. assert \initialized(dataPtr1);
CWE127_Buffer_Underread	Array access (from variable 'data') results in a null pointer dereference
CWE127_Buffer_Underread	Array index -5 is out of bounds.
CWE127_Buffer_Underread	Assigned value is garbage or undefined
CWE127_Buffer_Underread	Calling undeclared function alloca. Old style K&R code?
CWE127_Buffer_Underread	Completely invalid destination for assigns
CWE127_Buffer_Underread	Condition '5!=5' is always false
CWE127_Buffer_Underread	Condition '5==5' is always true
CWE127_Buffer_Underread	Condition 'data>=0' is always false
CWE127_Buffer_Underread	Condition 'data<10' is always true
CWE127_Buffer_Underread	Dereference of undefined pointer value
CWE127_Buffer_Underread	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused).
CWE127_Buffer_Underread	Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
CWE127_Buffer_Underread	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE127_Buffer_Underread	Easily used incorrectly; doesn't always \0-terminate or check for invalid pointers (CWE-120).
CWE127_Buffer_Underread	Function call argument is an uninitialized value
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_cpy_45_goodG2BData
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_cpy_68_goodG2BData
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_loop_45_goodG2BData
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_loop_68_goodG2BData
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_memcpy_45_goodG2BData
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_memcpy_68_goodG2BData
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_memmove_45_goodG2BData
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_memmove_68_goodG2BData
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_ncpy_45_goodG2BData
CWE127_Buffer_Underread	locals {dataBuffer} escaping the scope of goodG2B through CWE127_Buffer_Underread__char_declare_ncpy_68_goodG2BData
CWE127_Buffer_Underread	Memory leak: dataBuffer
CWE127_Buffer_Underread	Neither code nor specification for function alloca, generating default assigns from the prototype
CWE127_Buffer_Underread	Neither code nor specification for function connect, generating default assigns from the prototype
CWE127_Buffer_Underread	Null pointer passed as an argument to a 'nonnull' parameter
CWE127_Buffer_Underread	out of bounds read. assert \valid_read(data_0 + i);
CWE127_Buffer_Underread	out of bounds read. assert \valid_read(data_1 + i);
CWE127_Buffer_Underread	out of bounds read. assert \valid_read(data + i);
CWE127_Buffer_Underread	out of bounds read. assert \valid_read(data + i_0);
CWE127_Buffer_Underread	out of bounds write. assert \valid(dataBuffer_0 + (int)(100 - 1));
CWE127_Buffer_Underread	out of bounds write. assert \valid(dataBuffer + (int)(100 - 1));
CWE127_Buffer_Underread	Possible null pointer dereference: data
CWE127_Buffer_Underread	Same expression on both sides of '=='.
CWE127_Buffer_Underread	Same expression on both sides of '!='.
CWE127_Buffer_Underread	signed overflow. assert tmp_2 << 30 ≤ 2147483647;
CWE127_Buffer_Underread	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE127_Buffer_Underread	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE127_Buffer_Underread	The scope of the variable 'buffer' can be reduced.
CWE127_Buffer_Underread	The scope of the variable 'dataRef' can be reduced.
CWE127_Buffer_Underread	The scope of the variable 'recvResult' can be reduced.
CWE127_Buffer_Underread	Undefined behaviour, pointer arithmetic 'dataBuffer-8' is out of bounds.
CWE127_Buffer_Underread	Uninitialized variable: data
CWE127_Buffer_Underread	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE127_Buffer_Underread	Value stored to 'data' during its initialization is never read
CWE127_Buffer_Underread	Value stored to 'data' is never read
CWE127_Buffer_Underread	Variable 'dataBuffer' is assigned a value that is never used.
CWE127_Buffer_Underread	Variable 'data' is assigned a value that is never used.
CWE127_Buffer_Underread	Variable 'data' is not assigned a value.
CWE127_Buffer_Underread	Variable 'data' is reassigned a value before the old one has been used.
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_connect_socket_printf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_connect_socket_printf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_connect_socket_printf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_console_fprintf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_console_fprintf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_console_fprintf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_console_printf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_console_printf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_console_printf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_environment_fprintf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_environment_fprintf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_environment_fprintf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_environment_printf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_environment_printf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_environment_printf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_file_fprintf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_file_fprintf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_file_fprintf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_file_printf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_file_printf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_file_printf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_badData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE134_Uncontrolled_Format_String	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE134_Uncontrolled_Format_String	Completely invalid destination for assigns
CWE134_Uncontrolled_Format_String	Condition '5!=5' is always false
CWE134_Uncontrolled_Format_String	Condition '5==5' is always true
CWE134_Uncontrolled_Format_String	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused). Risk is low because the source is a constant string.
CWE134_Uncontrolled_Format_String	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE134_Uncontrolled_Format_String	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE134_Uncontrolled_Format_String	If format strings can be influenced by an attacker, they can be exploited (CWE-134). Use a constant for the format specification.
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_printf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_printf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_fprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_fprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_printf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_printf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_snprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_snprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_vfprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_vprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_console_vprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_fprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_fprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_printf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_printf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_snprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_snprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_vfprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_vprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_environment_vprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_fprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_fprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_printf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_printf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_snprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_snprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_vfprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_vfprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_vprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_file_vprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_printf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_45_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodB2G through CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68_goodB2GData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_printf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_printf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_fprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_fprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_printf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_printf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_snprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_snprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_vfprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_vprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_console_vprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_fprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_fprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_printf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_printf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_snprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_snprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_vfprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_vprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_environment_vprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_fprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_fprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_printf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_printf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_snprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_snprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_vfprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_vfprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_vprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_file_vprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_printf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_45_goodG2BData
CWE134_Uncontrolled_Format_String	locals {dataBuffer} escaping the scope of goodG2B through CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68_goodG2BData
CWE134_Uncontrolled_Format_String	Neither code nor specification for function __builtin_va_end, generating default assigns from the prototype
CWE134_Uncontrolled_Format_String	Neither code nor specification for function __builtin_va_start, generating default assigns from the prototype
CWE134_Uncontrolled_Format_String	Neither code nor specification for function connect, generating default assigns from the prototype
CWE134_Uncontrolled_Format_String	out of bounds read. assert \valid_read(data_0 + (unsigned int)(dataLen - 1));
CWE134_Uncontrolled_Format_String	out of bounds read. assert \valid_read(data + (unsigned int)(dataLen_0 - 1));
CWE134_Uncontrolled_Format_String	out of bounds read. assert \valid_read(data + (unsigned int)(dataLen - 1));
CWE134_Uncontrolled_Format_String	out of bounds write.
CWE134_Uncontrolled_Format_String	out of bounds write. assert \valid(data_0 + dataLen);
CWE134_Uncontrolled_Format_String	out of bounds write. assert \valid(data + dataLen);
CWE134_Uncontrolled_Format_String	out of bounds write. assert \valid(data + dataLen_0);
CWE134_Uncontrolled_Format_String	out of bounds write. assert \valid(replace);
CWE134_Uncontrolled_Format_String	out of bounds write. assert \valid(replace_0);
CWE134_Uncontrolled_Format_String	pointer comparison.
CWE134_Uncontrolled_Format_String	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace);
CWE134_Uncontrolled_Format_String	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace_0);
CWE134_Uncontrolled_Format_String	Same expression on both sides of '=='.
CWE134_Uncontrolled_Format_String	Same expression on both sides of '!='.
CWE134_Uncontrolled_Format_String	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE134_Uncontrolled_Format_String	The function 'goodB2GVaSinkB' is never used.
CWE134_Uncontrolled_Format_String	The function 'goodG2BVaSinkG' is never used.
CWE134_Uncontrolled_Format_String	The scope of the variable 'pFile' can be reduced.
CWE134_Uncontrolled_Format_String	The scope of the variable 'recvResult' can be reduced.
CWE134_Uncontrolled_Format_String	The scope of the variable 'replace' can be reduced.
CWE134_Uncontrolled_Format_String	Variable 'dataBuffer' is assigned a value that is never used.
CWE134_Uncontrolled_Format_String	Variable 'data' is assigned a value that is never used.
CWE188_Reliance_on_Data_Memory_Layout	Condition '5!=5' is always false
CWE188_Reliance_on_Data_Memory_Layout	Condition '5==5' is always true
CWE188_Reliance_on_Data_Memory_Layout	Same expression on both sides of '=='.
CWE188_Reliance_on_Data_Memory_Layout	Same expression on both sides of '!='.
CWE188_Reliance_on_Data_Memory_Layout	struct member 'Anonymous1::charFirst' is never used.
CWE188_Reliance_on_Data_Memory_Layout	struct member 'Anonymous1::charSecond' is never used.
CWE188_Reliance_on_Data_Memory_Layout	struct member 'Anonymous1::charThird' is never used.
CWE190_Integer_Overflow	Completely invalid destination for assigns
CWE190_Integer_Overflow	Condition '5!=5' is always false
CWE190_Integer_Overflow	Condition '5==5' is always true
CWE190_Integer_Overflow	Condition 'data>0' is always true
CWE190_Integer_Overflow	%lld in format string (no. 1) requires 'long long *' but the argument type is 'signed long *'.
CWE190_Integer_Overflow	Neither code nor specification for function connect, generating default assigns from the prototype
CWE190_Integer_Overflow	non-finite double value.
CWE190_Integer_Overflow	overflow in conversion from floating-point to integer.
CWE190_Integer_Overflow	Same expression on both sides of '=='.
CWE190_Integer_Overflow	Same expression on both sides of '!='.
CWE190_Integer_Overflow	signed overflow.
CWE190_Integer_Overflow	signed overflow. assert -2147483648 ≤ data_0 * data_0;
CWE190_Integer_Overflow	signed overflow. assert -2147483648 ≤ data_1 * data_1;
CWE190_Integer_Overflow	signed overflow. assert -2147483648 ≤ data * data;
CWE190_Integer_Overflow	signed overflow. assert data_0 + 1 ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert data_0 * 2 ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert data_0 * data_0 ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert data_0 * data_0 ≤ 9223372036854775807;
CWE190_Integer_Overflow	signed overflow. assert data_0 + (long long)1 ≤ 9223372036854775807;
CWE190_Integer_Overflow	signed overflow. assert data_0 * (long long)2 ≤ 9223372036854775807;
CWE190_Integer_Overflow	signed overflow. assert data_1 + 1 ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert data + 1 ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert data_1 * 2 ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert data_1 * data_1 ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert data_1 * data_1 ≤ 9223372036854775807;
CWE190_Integer_Overflow	signed overflow. assert data_1 + (long long)1 ≤ 9223372036854775807;
CWE190_Integer_Overflow	signed overflow. assert data_1 * (long long)2 ≤ 9223372036854775807;
CWE190_Integer_Overflow	signed overflow. assert data * 2 ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert data * data ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert data * data ≤ 9223372036854775807;
CWE190_Integer_Overflow	signed overflow. assert data + (long long)1 ≤ 9223372036854775807;
CWE190_Integer_Overflow	signed overflow. assert data * (long long)2 ≤ 9223372036854775807;
CWE190_Integer_Overflow	signed overflow. assert tmp_2 << 30 ≤ 2147483647;
CWE190_Integer_Overflow	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE190_Integer_Overflow	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE190_Integer_Overflow	The scope of the variable 'dataRef' can be reduced.
CWE190_Integer_Overflow	The scope of the variable 'recvResult' can be reduced.
CWE190_Integer_Overflow	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE190_Integer_Overflow	Value stored to 'data' during its initialization is never read
CWE190_Integer_Overflow	Value stored to 'data' is never read
CWE190_Integer_Overflow	Variable 'data' is assigned a value that is never used.
CWE190_Integer_Overflow	Variable 'data' is reassigned a value before the old one has been used.
CWE191_Integer_Underflow	Completely invalid destination for assigns
CWE191_Integer_Underflow	Condition '5!=5' is always false
CWE191_Integer_Underflow	Condition '5==5' is always true
CWE191_Integer_Underflow	Condition 'data>0' is always false
CWE191_Integer_Underflow	Condition 'data<0' is always true
CWE191_Integer_Underflow	%lld in format string (no. 1) requires 'long long *' but the argument type is 'signed long *'.
CWE191_Integer_Underflow	Neither code nor specification for function connect, generating default assigns from the prototype
CWE191_Integer_Underflow	Same expression on both sides of '=='.
CWE191_Integer_Underflow	Same expression on both sides of '!='.
CWE191_Integer_Underflow	signed overflow.
CWE191_Integer_Underflow	signed overflow. assert -2147483648 ≤ data_0 - 1;
CWE191_Integer_Underflow	signed overflow. assert -2147483648 ≤ data_0 * 2;
CWE191_Integer_Underflow	signed overflow. assert -2147483648 ≤ data - 1;
CWE191_Integer_Underflow	signed overflow. assert -2147483648 ≤ data_1 - 1;
CWE191_Integer_Underflow	signed overflow. assert -2147483648 ≤ data_1 * 2;
CWE191_Integer_Underflow	signed overflow. assert -2147483648 ≤ data * 2;
CWE191_Integer_Underflow	signed overflow. assert -9223372036854775808 ≤ data_0 - (long long)1;
CWE191_Integer_Underflow	signed overflow. assert -9223372036854775808 ≤ data_0 * (long long)2;
CWE191_Integer_Underflow	signed overflow. assert -9223372036854775808 ≤ data_1 - (long long)1;
CWE191_Integer_Underflow	signed overflow. assert -9223372036854775808 ≤ data_1 * (long long)2;
CWE191_Integer_Underflow	signed overflow. assert -9223372036854775808 ≤ data - (long long)1;
CWE191_Integer_Underflow	signed overflow. assert -9223372036854775808 ≤ data * (long long)2;
CWE191_Integer_Underflow	signed overflow. assert tmp_2 << 30 ≤ 2147483647;
CWE191_Integer_Underflow	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE191_Integer_Underflow	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE191_Integer_Underflow	The scope of the variable 'dataRef' can be reduced.
CWE191_Integer_Underflow	The scope of the variable 'recvResult' can be reduced.
CWE191_Integer_Underflow	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE191_Integer_Underflow	Value stored to 'data' during its initialization is never read
CWE191_Integer_Underflow	Value stored to 'data' is never read
CWE191_Integer_Underflow	Variable 'data' is assigned a value that is never used.
CWE191_Integer_Underflow	Variable 'data' is reassigned a value before the old one has been used.
CWE194_Unexpected_Sign_Extension	accessing out of bounds index. assert 0 ≤ data;
CWE194_Unexpected_Sign_Extension	accessing out of bounds index. assert 0 ≤ data_0;
CWE194_Unexpected_Sign_Extension	accessing out of bounds index. assert 0 ≤ data_1;
CWE194_Unexpected_Sign_Extension	accessing out of bounds index. assert data_0 < 100;
CWE194_Unexpected_Sign_Extension	accessing out of bounds index. assert data < 100;
CWE194_Unexpected_Sign_Extension	accessing out of bounds index. assert data_1 < 100;
CWE194_Unexpected_Sign_Extension	Array index -1 is out of bounds.
CWE194_Unexpected_Sign_Extension	Call to 'malloc' has an allocation size of 0 bytes
CWE194_Unexpected_Sign_Extension	Completely invalid destination for assigns
CWE194_Unexpected_Sign_Extension	Condition '5!=5' is always false
CWE194_Unexpected_Sign_Extension	Condition '5==5' is always true
CWE194_Unexpected_Sign_Extension	Condition 'data<100' is always true
CWE194_Unexpected_Sign_Extension	Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
CWE194_Unexpected_Sign_Extension	Easily used incorrectly; doesn't always \0-terminate or check for invalid pointers (CWE-120).
CWE194_Unexpected_Sign_Extension	Invalid malloc() argument nr 1. The value is -1 but the valid values are '0:'.
CWE194_Unexpected_Sign_Extension	Invalid memcpy() argument nr 3. The value is -1 but the valid values are '0:'.
CWE194_Unexpected_Sign_Extension	Invalid memmove() argument nr 3. The value is -1 but the valid values are '0:'.
CWE194_Unexpected_Sign_Extension	Invalid memset() argument nr 3. The value is -2 but the valid values are '0:'.
CWE194_Unexpected_Sign_Extension	Invalid strncpy() argument nr 3. The value is -1 but the valid values are '0:'.
CWE194_Unexpected_Sign_Extension	Memory allocation size is negative.
CWE194_Unexpected_Sign_Extension	Neither code nor specification for function connect, generating default assigns from the prototype
CWE194_Unexpected_Sign_Extension	out of bounds write. assert \valid(dataBuffer + (int)((int)data_0 - 1));
CWE194_Unexpected_Sign_Extension	out of bounds write. assert \valid(dataBuffer + (int)((int)data - 1));
CWE194_Unexpected_Sign_Extension	out of bounds write. assert \valid(dataBuffer + (int)((int)data_1 - 1));
CWE194_Unexpected_Sign_Extension	Same expression on both sides of '=='.
CWE194_Unexpected_Sign_Extension	Same expression on both sides of '!='.
CWE194_Unexpected_Sign_Extension	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE194_Unexpected_Sign_Extension	Size argument is greater than the length of the destination buffer
CWE194_Unexpected_Sign_Extension	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE194_Unexpected_Sign_Extension	The scope of the variable 'dataRef' can be reduced.
CWE194_Unexpected_Sign_Extension	The scope of the variable 'recvResult' can be reduced.
CWE194_Unexpected_Sign_Extension	The scope of the variable 'tempInt' can be reduced.
CWE194_Unexpected_Sign_Extension	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE194_Unexpected_Sign_Extension	Value stored to 'data' during its initialization is never read
CWE194_Unexpected_Sign_Extension	Value stored to 'data' is never read
CWE194_Unexpected_Sign_Extension	Variable 'data' is assigned a value that is never used.
CWE194_Unexpected_Sign_Extension	Variable 'data' is reassigned a value before the old one has been used.
CWE195_Signed_to_Unsigned_Conversion_Error	accessing out of bounds index. assert 0 ≤ data;
CWE195_Signed_to_Unsigned_Conversion_Error	accessing out of bounds index. assert 0 ≤ data_0;
CWE195_Signed_to_Unsigned_Conversion_Error	accessing out of bounds index. assert 0 ≤ data_1;
CWE195_Signed_to_Unsigned_Conversion_Error	accessing out of bounds index. assert data_0 < 100;
CWE195_Signed_to_Unsigned_Conversion_Error	accessing out of bounds index. assert data < 100;
CWE195_Signed_to_Unsigned_Conversion_Error	accessing out of bounds index. assert data_1 < 100;
CWE195_Signed_to_Unsigned_Conversion_Error	Array index -1 is out of bounds.
CWE195_Signed_to_Unsigned_Conversion_Error	Completely invalid destination for assigns
CWE195_Signed_to_Unsigned_Conversion_Error	Condition '5!=5' is always false
CWE195_Signed_to_Unsigned_Conversion_Error	Condition '5==5' is always true
CWE195_Signed_to_Unsigned_Conversion_Error	Condition 'data<100' is always true
CWE195_Signed_to_Unsigned_Conversion_Error	Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
CWE195_Signed_to_Unsigned_Conversion_Error	Easily used incorrectly; doesn't always \0-terminate or check for invalid pointers (CWE-120).
CWE195_Signed_to_Unsigned_Conversion_Error	Invalid malloc() argument nr 1. The value is -1 but the valid values are '0:'.
CWE195_Signed_to_Unsigned_Conversion_Error	Invalid memcpy() argument nr 3. The value is -1 but the valid values are '0:'.
CWE195_Signed_to_Unsigned_Conversion_Error	Invalid memmove() argument nr 3. The value is -1 but the valid values are '0:'.
CWE195_Signed_to_Unsigned_Conversion_Error	Invalid memset() argument nr 3. The value is -2 but the valid values are '0:'.
CWE195_Signed_to_Unsigned_Conversion_Error	Invalid strncpy() argument nr 3. The value is -1 but the valid values are '0:'.
CWE195_Signed_to_Unsigned_Conversion_Error	Memory allocation size is negative.
CWE195_Signed_to_Unsigned_Conversion_Error	Neither code nor specification for function connect, generating default assigns from the prototype
CWE195_Signed_to_Unsigned_Conversion_Error	out of bounds write. assert \valid(dataBuffer + (int)(data_0 - 1));
CWE195_Signed_to_Unsigned_Conversion_Error	out of bounds write. assert \valid(dataBuffer + (int)(data - 1));
CWE195_Signed_to_Unsigned_Conversion_Error	out of bounds write. assert \valid(dataBuffer + (int)(data_1 - 1));
CWE195_Signed_to_Unsigned_Conversion_Error	Same expression on both sides of '=='.
CWE195_Signed_to_Unsigned_Conversion_Error	Same expression on both sides of '!='.
CWE195_Signed_to_Unsigned_Conversion_Error	signed overflow. assert -2147483648 ≤ data_0 - 1;
CWE195_Signed_to_Unsigned_Conversion_Error	signed overflow. assert -2147483648 ≤ data - 1;
CWE195_Signed_to_Unsigned_Conversion_Error	signed overflow. assert -2147483648 ≤ data_1 - 1;
CWE195_Signed_to_Unsigned_Conversion_Error	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE195_Signed_to_Unsigned_Conversion_Error	Size argument is greater than the length of the destination buffer
CWE195_Signed_to_Unsigned_Conversion_Error	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE195_Signed_to_Unsigned_Conversion_Error	The scope of the variable 'dataRef' can be reduced.
CWE195_Signed_to_Unsigned_Conversion_Error	The scope of the variable 'recvResult' can be reduced.
CWE195_Signed_to_Unsigned_Conversion_Error	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE195_Signed_to_Unsigned_Conversion_Error	Value stored to 'data' during its initialization is never read
CWE195_Signed_to_Unsigned_Conversion_Error	Value stored to 'data' is never read
CWE195_Signed_to_Unsigned_Conversion_Error	Variable 'data' is assigned a value that is never used.
CWE195_Signed_to_Unsigned_Conversion_Error	Variable 'data' is reassigned a value before the old one has been used.
CWE196_Unsigned_to_Signed_Conversion_Error	Condition '5!=5' is always false
CWE196_Unsigned_to_Signed_Conversion_Error	Condition '5==5' is always true
CWE196_Unsigned_to_Signed_Conversion_Error	Same expression on both sides of '=='.
CWE196_Unsigned_to_Signed_Conversion_Error	Same expression on both sides of '!='.
CWE197_Numeric_Truncation_Error	Completely invalid destination for assigns
CWE197_Numeric_Truncation_Error	Condition '5!=5' is always false
CWE197_Numeric_Truncation_Error	Condition '5==5' is always true
CWE197_Numeric_Truncation_Error	Neither code nor specification for function connect, generating default assigns from the prototype
CWE197_Numeric_Truncation_Error	Same expression on both sides of '=='.
CWE197_Numeric_Truncation_Error	Same expression on both sides of '!='.
CWE197_Numeric_Truncation_Error	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE197_Numeric_Truncation_Error	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE197_Numeric_Truncation_Error	The scope of the variable 'dataRef' can be reduced.
CWE197_Numeric_Truncation_Error	The scope of the variable 'recvResult' can be reduced.
CWE197_Numeric_Truncation_Error	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE197_Numeric_Truncation_Error	Value stored to 'data' during its initialization is never read
CWE197_Numeric_Truncation_Error	Value stored to 'data' is never read
CWE197_Numeric_Truncation_Error	Variable 'data' is assigned a value that is never used.
CWE197_Numeric_Truncation_Error	Variable 'data' is reassigned a value before the old one has been used.
CWE23_Relative_Path_Traversal	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'badData' upon returning to the caller.  This will be a dangling reference
CWE23_Relative_Path_Traversal	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE23_Relative_Path_Traversal	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE23_Relative_Path_Traversal	Condition '5!=5' is always false
CWE23_Relative_Path_Traversal	Condition '5==5' is always true
CWE23_Relative_Path_Traversal	Does not check for buffer overflows when concatenating to destination (CWE-120). Consider using strcat_s, strncat, or strlcat (warning, strncat is easily misused). Risk is low because the source is a constant string.
CWE23_Relative_Path_Traversal	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE23_Relative_Path_Traversal	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE23_Relative_Path_Traversal	Same expression on both sides of '=='.
CWE23_Relative_Path_Traversal	Same expression on both sides of '!='.
CWE23_Relative_Path_Traversal	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE23_Relative_Path_Traversal	The scope of the variable 'pFile' can be reduced.
CWE23_Relative_Path_Traversal	The scope of the variable 'recvResult' can be reduced.
CWE23_Relative_Path_Traversal	The scope of the variable 'replace' can be reduced.
CWE23_Relative_Path_Traversal	Variable 'dataBuffer' is assigned a value that is never used.
CWE23_Relative_Path_Traversal	Variable 'data' is assigned a value that is never used.
CWE23_Relative_Path_Traversal	Variable 'pFile' is reassigned a value before the old one has been used.
CWE242_Use_of_Inherently_Dangerous_Function	Condition '5!=5' is always false
CWE242_Use_of_Inherently_Dangerous_Function	Condition '5==5' is always true
CWE242_Use_of_Inherently_Dangerous_Function	Does not check for buffer overflows (CWE-120, CWE-20). Use fgets() instead.
CWE242_Use_of_Inherently_Dangerous_Function	Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead.
CWE242_Use_of_Inherently_Dangerous_Function	Same expression on both sides of '=='.
CWE242_Use_of_Inherently_Dangerous_Function	Same expression on both sides of '!='.
CWE242_Use_of_Inherently_Dangerous_Function	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE252_Unchecked_Return_Value	Condition '5!=5' is always false
CWE252_Unchecked_Return_Value	Condition '5==5' is always true
CWE252_Unchecked_Return_Value	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE252_Unchecked_Return_Value	It's unclear if the %s limit in the format string is small enough (CWE-120). Check that the limit is sufficiently small, or use a different input function.
CWE252_Unchecked_Return_Value	Neither code nor specification for function sscanf, generating default assigns from the prototype
CWE252_Unchecked_Return_Value	Same expression on both sides of '=='.
CWE252_Unchecked_Return_Value	Same expression on both sides of '!='.
CWE252_Unchecked_Return_Value	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE253_Incorrect_Check_of_Function_Return_Value	Condition '5!=5' is always false
CWE253_Incorrect_Check_of_Function_Return_Value	Condition '5==5' is always true
CWE253_Incorrect_Check_of_Function_Return_Value	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE253_Incorrect_Check_of_Function_Return_Value	It's unclear if the %s limit in the format string is small enough (CWE-120). Check that the limit is sufficiently small, or use a different input function.
CWE253_Incorrect_Check_of_Function_Return_Value	Neither code nor specification for function sscanf, generating default assigns from the prototype
CWE253_Incorrect_Check_of_Function_Return_Value	pointer comparison.
CWE253_Incorrect_Check_of_Function_Return_Value	Same expression on both sides of '=='.
CWE253_Incorrect_Check_of_Function_Return_Value	Same expression on both sides of '!='.
CWE253_Incorrect_Check_of_Function_Return_Value	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE364_Signal_Handler_Race_Condition	Condition '5!=5' is always false
CWE364_Signal_Handler_Race_Condition	Condition '5==5' is always true
CWE364_Signal_Handler_Race_Condition	out of bounds write.
CWE364_Signal_Handler_Race_Condition	Same expression on both sides of '=='.
CWE364_Signal_Handler_Race_Condition	Same expression on both sides of '!='.
CWE366_Race_Condition_Within_Thread	Completely invalid destination for assigns clause *((char *)args + (0 ..)).
CWE366_Race_Condition_Within_Thread	Completely invalid destination for assigns clause *lock. Ignoring.
CWE366_Race_Condition_Within_Thread	Completely invalid destination for assigns clause *start. Ignoring.
CWE366_Race_Condition_Within_Thread	Condition '5!=5' is always false
CWE366_Race_Condition_Within_Thread	Condition '5==5' is always true
CWE366_Race_Condition_Within_Thread	Neither code nor specification for function stdThreadCreate, generating default assigns from the prototype
CWE366_Race_Condition_Within_Thread	Neither code nor specification for function stdThreadLockCreate, generating default assigns from the prototype
CWE366_Race_Condition_Within_Thread	Neither code nor specification for function stdThreadLockDestroy, generating default assigns from the prototype
CWE366_Race_Condition_Within_Thread	Same expression on both sides of '=='.
CWE366_Race_Condition_Within_Thread	Same expression on both sides of '!='.
CWE367_TOC_TOU	accessing out of bounds index.
CWE367_TOC_TOU	Condition '5!=5' is always false
CWE367_TOC_TOU	Condition '5==5' is always true
CWE367_TOC_TOU	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE367_TOC_TOU	Neither code nor specification for function access, generating default assigns from the prototype
CWE367_TOC_TOU	Neither code nor specification for function stat, generating default assigns from the prototype
CWE367_TOC_TOU	Same expression on both sides of '=='.
CWE367_TOC_TOU	Same expression on both sides of '!='.
CWE367_TOC_TOU	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE369_Divide_by_Zero	Completely invalid destination for assigns
CWE369_Divide_by_Zero	Condition '5!=5' is always false
CWE369_Divide_by_Zero	Condition '5==5' is always true
CWE369_Divide_by_Zero	Condition 'data!=0' is always false
CWE369_Divide_by_Zero	Division by zero
CWE369_Divide_by_Zero	Division by zero.
CWE369_Divide_by_Zero	division by zero. assert data ≢ 0;
CWE369_Divide_by_Zero	division by zero. assert data_0 ≢ 0;
CWE369_Divide_by_Zero	division by zero. assert data_1 ≢ 0;
CWE369_Divide_by_Zero	Floating-point constant 0.000001 is not represented exactly. Will use 0x1.0c6f7a0b5ed8dp-20. See documentation for option -warn-decimal-float
CWE369_Divide_by_Zero	Neither code nor specification for function connect, generating default assigns from the prototype
CWE369_Divide_by_Zero	Neither code nor specification for function fabs, generating default assigns from the prototype
CWE369_Divide_by_Zero	non-finite double value.
CWE369_Divide_by_Zero	non-finite double value. assert \is_finite((double)(100.0 / (double)data));
CWE369_Divide_by_Zero	non-finite double value. assert \is_finite((double)(100.0 / (double)data_0));
CWE369_Divide_by_Zero	non-finite double value. assert \is_finite((double)(100.0 / (double)data_1));
CWE369_Divide_by_Zero	non-finite float value.
CWE369_Divide_by_Zero	overflow in conversion from floating-point to integer.
CWE369_Divide_by_Zero	Same expression on both sides of '=='.
CWE369_Divide_by_Zero	Same expression on both sides of '!='.
CWE369_Divide_by_Zero	signed overflow. assert tmp_2 << 30 ≤ 2147483647;
CWE369_Divide_by_Zero	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE369_Divide_by_Zero	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE369_Divide_by_Zero	The scope of the variable 'dataRef' can be reduced.
CWE369_Divide_by_Zero	The scope of the variable 'recvResult' can be reduced.
CWE369_Divide_by_Zero	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE369_Divide_by_Zero	Value stored to 'data' during its initialization is never read
CWE369_Divide_by_Zero	Value stored to 'data' is never read
CWE369_Divide_by_Zero	Variable 'data' is assigned a value that is never used.
CWE369_Divide_by_Zero	Variable 'data' is reassigned a value before the old one has been used.
CWE36_Absolute_Path_Traversal	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'badData' upon returning to the caller.  This will be a dangling reference
CWE36_Absolute_Path_Traversal	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE36_Absolute_Path_Traversal	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE36_Absolute_Path_Traversal	Condition '5!=5' is always false
CWE36_Absolute_Path_Traversal	Condition '5==5' is always true
CWE36_Absolute_Path_Traversal	Does not check for buffer overflows when concatenating to destination (CWE-120). Consider using strcat_s, strncat, or strlcat (warning, strncat is easily misused). Risk is low because the source is a constant string.
CWE36_Absolute_Path_Traversal	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE36_Absolute_Path_Traversal	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE36_Absolute_Path_Traversal	Same expression on both sides of '=='.
CWE36_Absolute_Path_Traversal	Same expression on both sides of '!='.
CWE36_Absolute_Path_Traversal	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE36_Absolute_Path_Traversal	The scope of the variable 'pFile' can be reduced.
CWE36_Absolute_Path_Traversal	The scope of the variable 'recvResult' can be reduced.
CWE36_Absolute_Path_Traversal	The scope of the variable 'replace' can be reduced.
CWE36_Absolute_Path_Traversal	Variable 'dataBuffer' is assigned a value that is never used.
CWE36_Absolute_Path_Traversal	Variable 'data' is assigned a value that is never used.
CWE36_Absolute_Path_Traversal	Variable 'pFile' is reassigned a value before the old one has been used.
CWE377_Insecure_Temporary_File	Calling undeclared function mktemp. Old style K&R code?
CWE377_Insecure_Temporary_File	Calling undeclared function tempnam. Old style K&R code?
CWE377_Insecure_Temporary_File	Call to function 'mktemp' is insecure as it always creates or uses insecure temporary file.  Use 'mkstemp' instead
CWE377_Insecure_Temporary_File	Completely invalid destination for assigns clause *((char *)x_0 + (0 ..)).
CWE377_Insecure_Temporary_File	Completely invalid destination for assigns clause *((char *)x_1 + (0 ..)).
CWE377_Insecure_Temporary_File	Completely invalid destination for assigns clause *(s + (..)). Ignoring.
CWE377_Insecure_Temporary_File	Condition '5!=5' is always false
CWE377_Insecure_Temporary_File	Condition '5==5' is always true
CWE377_Insecure_Temporary_File	Neither code nor specification for function mktemp, generating default assigns from the prototype
CWE377_Insecure_Temporary_File	Neither code nor specification for function tempnam, generating default assigns from the prototype
CWE377_Insecure_Temporary_File	Same expression on both sides of '=='.
CWE377_Insecure_Temporary_File	Same expression on both sides of '!='.
CWE390_Error_Without_Action	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE390_Error_Without_Action	Condition '5!=5' is always false
CWE390_Error_Without_Action	Condition '5==5' is always true
CWE390_Error_Without_Action	Either the condition 'fileDesc==NULL' is redundant or there is possible null pointer dereference: fileDesc.
CWE390_Error_Without_Action	non-finite double value. assert \is_finite(doubleNumber);
CWE390_Error_Without_Action	non-finite double value. assert \is_finite(doubleNumber_0);
CWE390_Error_Without_Action	Same expression on both sides of '=='.
CWE390_Error_Without_Action	Same expression on both sides of '!='.
CWE390_Error_Without_Action	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE390_Error_Without_Action	Variable 'fileDesc' is reassigned a value before the old one has been used.
CWE391_Unchecked_Error_Condition	Condition '5!=5' is always false
CWE391_Unchecked_Error_Condition	Condition '5==5' is always true
CWE391_Unchecked_Error_Condition	non-finite double value. assert \is_finite(doubleNumber);
CWE391_Unchecked_Error_Condition	non-finite double value. assert \is_finite(doubleNumber_0);
CWE391_Unchecked_Error_Condition	Same expression on both sides of '=='.
CWE391_Unchecked_Error_Condition	Same expression on both sides of '!='.
CWE391_Unchecked_Error_Condition	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE396_Catch_Generic_Exception	Condition '5!=5' is always false
CWE396_Catch_Generic_Exception	Condition '5==5' is always true
CWE396_Catch_Generic_Exception	Same expression on both sides of '=='.
CWE396_Catch_Generic_Exception	Same expression on both sides of '!='.
CWE397_Throw_Generic_Exception	Condition '5!=5' is always false
CWE397_Throw_Generic_Exception	Condition '5==5' is always true
CWE397_Throw_Generic_Exception	Consecutive return, break, continue, goto or throw statements are unnecessary.
CWE397_Throw_Generic_Exception	Same expression on both sides of '=='.
CWE397_Throw_Generic_Exception	Same expression on both sides of '!='.
CWE398_Poor_Code_Quality	Condition '5!=5' is always false
CWE398_Poor_Code_Quality	Condition '5==5' is always true
CWE398_Poor_Code_Quality	Redundant assignment of 'intOne' to itself.
CWE398_Poor_Code_Quality	Redundant code: Found a statement that begins with numeric constant.
CWE398_Poor_Code_Quality	Same expression on both sides of '=='.
CWE398_Poor_Code_Quality	Same expression on both sides of '!='.
CWE398_Poor_Code_Quality	signed overflow. assert i_0 + 1 ≤ 2147483647;
CWE398_Poor_Code_Quality	signed overflow. assert i + 1 ≤ 2147483647;
CWE400_Resource_Exhaustion	Calling undeclared function usleep. Old style K&R code?
CWE400_Resource_Exhaustion	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE400_Resource_Exhaustion	Completely invalid destination for assigns
CWE400_Resource_Exhaustion	Condition '5!=5' is always false
CWE400_Resource_Exhaustion	Condition '5==5' is always true
CWE400_Resource_Exhaustion	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE400_Resource_Exhaustion	Neither code nor specification for function connect, generating default assigns from the prototype
CWE400_Resource_Exhaustion	Neither code nor specification for function usleep, generating default assigns from the prototype
CWE400_Resource_Exhaustion	Same expression on both sides of '=='.
CWE400_Resource_Exhaustion	Same expression on both sides of '!='.
CWE400_Resource_Exhaustion	signed overflow. assert tmp_2 << 30 ≤ 2147483647;
CWE400_Resource_Exhaustion	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE400_Resource_Exhaustion	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE400_Resource_Exhaustion	The scope of the variable 'countRef' can be reduced.
CWE400_Resource_Exhaustion	The scope of the variable 'filename' can be reduced.
CWE400_Resource_Exhaustion	The scope of the variable 'i' can be reduced.
CWE400_Resource_Exhaustion	The scope of the variable 'recvResult' can be reduced.
CWE400_Resource_Exhaustion	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE400_Resource_Exhaustion	Value stored to 'count' during its initialization is never read
CWE400_Resource_Exhaustion	Value stored to 'count' is never read
CWE400_Resource_Exhaustion	Variable 'count' is assigned a value that is never used.
CWE400_Resource_Exhaustion	Variable 'count' is reassigned a value before the old one has been used.
CWE400_Resource_Exhaustion	Variable 'pFile' is reassigned a value before the old one has been used.
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X returned to caller
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__char_calloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__char_malloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__char_realloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__int64_t_calloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__int64_t_malloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__int64_t_realloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__int_calloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__int_malloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__int_realloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__twoIntsStruct_calloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__twoIntsStruct_malloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__twoIntsStruct_realloc_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory allocated by call to alloca() on line X is still referred to by the global variable 'CWE401_Memory_Leak__strdup_char_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	Address of stack memory associated with local variable 'dataGoodBuffer' is still referred to by the global variable 'goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE401_Memory_Leak	all target addresses were invalid. This path is assumed to be dead.
CWE401_Memory_Leak	Argument to 'delete' is the address of the local variable 'dataGoodBuffer', which is not memory allocated by 'new'
CWE401_Memory_Leak	Argument to 'delete[]' is the address of the local variable 'dataGoodBuffer', which is not memory allocated by 'new[]'
CWE401_Memory_Leak	Calling undeclared function alloca. Old style K&R code?
CWE401_Memory_Leak	Common realloc mistake: 'data' nulled but not freed upon failure
CWE401_Memory_Leak	Condition '5!=5' is always false
CWE401_Memory_Leak	Condition '5==5' is always true
CWE401_Memory_Leak	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused). Risk is low because the source is a constant string.
CWE401_Memory_Leak	Memory allocated by alloca() should not be deallocated
CWE401_Memory_Leak	Memory leak: data
CWE401_Memory_Leak	Neither code nor specification for function alloca, generating default assigns from the prototype
CWE401_Memory_Leak	No code nor implicit assigns clause for function calloc, generating default assigns from the prototype
CWE401_Memory_Leak	out of bounds write. assert \valid(data + 0);
CWE401_Memory_Leak	out of bounds write. assert \valid(data_0 + 0);
CWE401_Memory_Leak	out of bounds write. assert \valid(&(data_0 + 0)->intOne);
CWE401_Memory_Leak	out of bounds write. assert \valid(&(data_0 + 0)->intTwo);
CWE401_Memory_Leak	out of bounds write. assert \valid(&(data + 0)->intOne);
CWE401_Memory_Leak	out of bounds write. assert \valid(&(data + 0)->intTwo);
CWE401_Memory_Leak	pointer comparison. assert \pointer_comparable((void *)data, (void *)0);
CWE401_Memory_Leak	pointer comparison. assert \pointer_comparable((void *)tmpData_0, (void *)0);
CWE401_Memory_Leak	pointer comparison. assert \pointer_comparable((void *)tmpData, (void *)0);
CWE401_Memory_Leak	Potential leak of memory pointed to by 'data'
CWE401_Memory_Leak	Potential leak of memory pointed to by 'myUnion.unionFirst'
CWE401_Memory_Leak	Same expression on both sides of '=='.
CWE401_Memory_Leak	Same expression on both sides of '!='.
CWE401_Memory_Leak	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE401_Memory_Leak	Value stored to 'data' during its initialization is never read
CWE401_Memory_Leak	Value stored to 'data' is never read
CWE401_Memory_Leak	Variable 'data' is assigned a value that is never used.
CWE401_Memory_Leak	Variable 'data' is reassigned a value before the old one has been used.
CWE404_Improper_Resource_Shutdown	Condition '5!=5' is always false
CWE404_Improper_Resource_Shutdown	Condition '5==5' is always true
CWE404_Improper_Resource_Shutdown	Same expression on both sides of '=='.
CWE404_Improper_Resource_Shutdown	Same expression on both sides of '!='.
CWE404_Improper_Resource_Shutdown	The scope of the variable 'dataRef' can be reduced.
CWE404_Improper_Resource_Shutdown	Value stored to 'data' during its initialization is never read
CWE404_Improper_Resource_Shutdown	Value stored to 'data' is never read
CWE404_Improper_Resource_Shutdown	Variable 'data' is assigned a value that is never used.
CWE404_Improper_Resource_Shutdown	Variable 'data' is reassigned a value before the old one has been used.
CWE415_Double_Free	Attempt to free released memory
CWE415_Double_Free	Condition '5!=5' is always false
CWE415_Double_Free	Condition '5==5' is always true
CWE415_Double_Free	Deallocating a deallocated pointer: data
CWE415_Double_Free	Memory pointed to by 'data' is freed twice.
CWE415_Double_Free	Potential leak of memory pointed to by 'data'
CWE415_Double_Free	Potential leak of memory pointed to by 'myUnion.unionFirst'
CWE415_Double_Free	Returning/dereferencing 'data' after it is deallocated / released
CWE415_Double_Free	Same expression on both sides of '=='.
CWE415_Double_Free	Same expression on both sides of '!='.
CWE415_Double_Free	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE415_Double_Free	Use of memory after it is freed
CWE415_Double_Free	Value stored to 'data' during its initialization is never read
CWE415_Double_Free	Value stored to 'data' is never read
CWE415_Double_Free	Variable 'data' is assigned a value that is never used.
CWE415_Double_Free	Variable 'data' is reassigned a value before the old one has been used.
CWE416_Use_After_Free	Access to field 'intOne' results in a dereference of a null pointer (loaded from variable 'data')
CWE416_Use_After_Free	Array access (from variable 'data') results in a null pointer dereference
CWE416_Use_After_Free	Condition '5!=5' is always false
CWE416_Use_After_Free	Condition '5==5' is always true
CWE416_Use_After_Free	Dereference of null pointer
CWE416_Use_After_Free	Dereference of null pointer (loaded from variable 'data')
CWE416_Use_After_Free	Memory leak: data
CWE416_Use_After_Free	out of bounds read. assert \valid_read(data + 0);
CWE416_Use_After_Free	out of bounds write. assert \valid(data + i);
CWE416_Use_After_Free	out of bounds write. assert \valid(data + i_0);
CWE416_Use_After_Free	out of bounds write. assert \valid(&(data + i_0)->intOne);
CWE416_Use_After_Free	out of bounds write. assert \valid(&(data + i)->intOne);
CWE416_Use_After_Free	out of bounds write. assert \valid(data + (int)(100 - 1));
CWE416_Use_After_Free	Potential leak of memory pointed to by 'data'
CWE416_Use_After_Free	Same expression on both sides of '=='.
CWE416_Use_After_Free	Same expression on both sides of '!='.
CWE416_Use_After_Free	Use of memory after it is freed
CWE416_Use_After_Free	Value stored to 'data' during its initialization is never read
CWE416_Use_After_Free	Variable 'data' is assigned a value that is never used.
CWE416_Use_After_Free	Variable 'data' is reassigned a value before the old one has been used.
CWE426_Untrusted_Search_Path	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE426_Untrusted_Search_Path__char_popen_45_badData' upon returning to the caller.  This will be a dangling reference
CWE426_Untrusted_Search_Path	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE426_Untrusted_Search_Path__char_popen_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE426_Untrusted_Search_Path	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE426_Untrusted_Search_Path__char_system_45_badData' upon returning to the caller.  This will be a dangling reference
CWE426_Untrusted_Search_Path	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE426_Untrusted_Search_Path__char_system_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE426_Untrusted_Search_Path	Calling undeclared function pclose. Old style K&R code?
CWE426_Untrusted_Search_Path	Calling undeclared function popen. Old style K&R code?
CWE426_Untrusted_Search_Path	Completely invalid destination for assigns clause *x_0. Ignoring.
CWE426_Untrusted_Search_Path	Condition '5!=5' is always false
CWE426_Untrusted_Search_Path	Condition '5==5' is always true
CWE426_Untrusted_Search_Path	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused).
CWE426_Untrusted_Search_Path	locals {dataBuffer} escaping the scope of goodG2B through CWE426_Untrusted_Search_Path__char_popen_45_goodG2BData
CWE426_Untrusted_Search_Path	locals {dataBuffer} escaping the scope of goodG2B through CWE426_Untrusted_Search_Path__char_popen_68_goodG2BData
CWE426_Untrusted_Search_Path	locals {dataBuffer} escaping the scope of goodG2B through CWE426_Untrusted_Search_Path__char_system_45_goodG2BData
CWE426_Untrusted_Search_Path	locals {dataBuffer} escaping the scope of goodG2B through CWE426_Untrusted_Search_Path__char_system_68_goodG2BData
CWE426_Untrusted_Search_Path	Neither code nor specification for function pclose, generating default assigns from the prototype
CWE426_Untrusted_Search_Path	Neither code nor specification for function popen, generating default assigns from the prototype
CWE426_Untrusted_Search_Path	Same expression on both sides of '=='.
CWE426_Untrusted_Search_Path	Same expression on both sides of '!='.
CWE426_Untrusted_Search_Path	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE426_Untrusted_Search_Path	Variable 'dataBuffer' is assigned a value that is never used.
CWE426_Untrusted_Search_Path	Variable 'data' is assigned a value that is never used.
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45_badData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_console_45_badData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_console_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_environment_45_badData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_environment_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_file_45_badData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_file_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_45_badData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE427_Uncontrolled_Search_Path_Element	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE427_Uncontrolled_Search_Path_Element	Completely invalid destination for assigns
CWE427_Uncontrolled_Search_Path_Element	Condition '5!=5' is always false
CWE427_Uncontrolled_Search_Path_Element	Condition '5==5' is always true
CWE427_Uncontrolled_Search_Path_Element	Does not check for buffer overflows when concatenating to destination (CWE-120). Consider using strcat_s, strncat, or strlcat (warning, strncat is easily misused).
CWE427_Uncontrolled_Search_Path_Element	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE427_Uncontrolled_Search_Path_Element	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_68_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_console_45_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_console_68_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_environment_45_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_environment_68_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_file_45_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_file_68_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_45_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	locals {dataBuffer} escaping the scope of goodG2B through CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_68_goodG2BData
CWE427_Uncontrolled_Search_Path_Element	Neither code nor specification for function connect, generating default assigns from the prototype
CWE427_Uncontrolled_Search_Path_Element	Neither code nor specification for function putenv, generating default assigns from the prototype
CWE427_Uncontrolled_Search_Path_Element	out of bounds read. assert \valid_read(data_0 + (unsigned int)(dataLen - 1));
CWE427_Uncontrolled_Search_Path_Element	out of bounds read. assert \valid_read(data + (unsigned int)(dataLen - 1));
CWE427_Uncontrolled_Search_Path_Element	out of bounds write.
CWE427_Uncontrolled_Search_Path_Element	out of bounds write. assert \valid(data_0 + dataLen);
CWE427_Uncontrolled_Search_Path_Element	out of bounds write. assert \valid(data + dataLen);
CWE427_Uncontrolled_Search_Path_Element	out of bounds write. assert \valid(replace);
CWE427_Uncontrolled_Search_Path_Element	pointer comparison.
CWE427_Uncontrolled_Search_Path_Element	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace);
CWE427_Uncontrolled_Search_Path_Element	Same expression on both sides of '=='.
CWE427_Uncontrolled_Search_Path_Element	Same expression on both sides of '!='.
CWE427_Uncontrolled_Search_Path_Element	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE427_Uncontrolled_Search_Path_Element	The scope of the variable 'pFile' can be reduced.
CWE427_Uncontrolled_Search_Path_Element	The scope of the variable 'recvResult' can be reduced.
CWE427_Uncontrolled_Search_Path_Element	The scope of the variable 'replace' can be reduced.
CWE427_Uncontrolled_Search_Path_Element	Variable 'dataBuffer' is assigned a value that is never used.
CWE427_Uncontrolled_Search_Path_Element	Variable 'data' is assigned a value that is never used.
CWE440_Expected_Behavior_Violation	Exception thrown in function declared not to throw exceptions.
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value.
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(&data);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(data + i);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(data + i_0);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(data + i_1);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(data + i_2);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(data + i_3);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(data + i_4);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(&(data + i)->intOne);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(&(data + i)->intTwo);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(&data.intOne);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(&data.intTwo);
CWE457_Use_of_Uninitialized_Variable	accessing uninitialized left-value. assert \initialized(dataPtr);
CWE457_Use_of_Uninitialized_Variable	all target addresses were invalid. This path is assumed to be dead.
CWE457_Use_of_Uninitialized_Variable	Calling undeclared function alloca. Old style K&R code?
CWE457_Use_of_Uninitialized_Variable	Condition '5!=5' is always false
CWE457_Use_of_Uninitialized_Variable	Condition '5==5' is always true
CWE457_Use_of_Uninitialized_Variable	Dereference of undefined pointer value
CWE457_Use_of_Uninitialized_Variable	Function call argument is an uninitialized value
CWE457_Use_of_Uninitialized_Variable	Memory leak: data
CWE457_Use_of_Uninitialized_Variable	Neither code nor specification for function alloca, generating default assigns from the prototype
CWE457_Use_of_Uninitialized_Variable	non-finite double value. assert \is_finite(*data);
CWE457_Use_of_Uninitialized_Variable	non-finite double value. assert \is_finite(*(data + i));
CWE457_Use_of_Uninitialized_Variable	non-finite double value. assert \is_finite(*(data + i_0));
CWE457_Use_of_Uninitialized_Variable	non-finite double value. assert \is_finite(*(data + i_1));
CWE457_Use_of_Uninitialized_Variable	non-finite double value. assert \is_finite(*(data + i_2));
CWE457_Use_of_Uninitialized_Variable	non-finite double value. assert \is_finite(*(data + i_3));
CWE457_Use_of_Uninitialized_Variable	non-finite double value. assert \is_finite(*(data + i_4));
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(data + i);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(data + i_0);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(&(data + i_0)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(data + i_1);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(&(data + i_1)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(data + i_2);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(&(data + i_2)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(data + i_3);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(&(data + i_3)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(data + i_4);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(&(data + i_4)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds read. assert \valid_read(&(data + i)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(data);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(data + i);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(data + i_0);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(&(data + i_0)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(data + i_1);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(&(data + i_1)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(data + i_2);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(&(data + i_2)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(data + i_3);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(&(data + i_3)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(&(data + i)->intOne);
CWE457_Use_of_Uninitialized_Variable	out of bounds write. assert \valid(&data->intOne);
CWE457_Use_of_Uninitialized_Variable	Potential leak of memory pointed to by 'badClassObject'
CWE457_Use_of_Uninitialized_Variable	Potential leak of memory pointed to by 'data'
CWE457_Use_of_Uninitialized_Variable	Potential leak of memory pointed to by 'goodClassObject'
CWE457_Use_of_Uninitialized_Variable	Same expression on both sides of '=='.
CWE457_Use_of_Uninitialized_Variable	Same expression on both sides of '!='.
CWE457_Use_of_Uninitialized_Variable	The scope of the variable 'data' can be reduced.
CWE457_Use_of_Uninitialized_Variable	Uninitialized variable: data
CWE457_Use_of_Uninitialized_Variable	Value stored to 'data' during its initialization is never read
CWE457_Use_of_Uninitialized_Variable	Variable 'data' is not assigned a value.
CWE457_Use_of_Uninitialized_Variable	Variable 'data' is reassigned a value before the old one has been used.
CWE459_Incomplete_Cleanup	Calling undeclared function mktemp. Old style K&R code?
CWE459_Incomplete_Cleanup	Call to function 'mktemp' is insecure as it always creates or uses insecure temporary file.  Use 'mkstemp' instead
CWE459_Incomplete_Cleanup	Condition '5!=5' is always false
CWE459_Incomplete_Cleanup	Condition '5==5' is always true
CWE459_Incomplete_Cleanup	Neither code nor specification for function mktemp, generating default assigns from the prototype
CWE459_Incomplete_Cleanup	Neither code nor specification for function unlink, generating default assigns from the prototype
CWE459_Incomplete_Cleanup	Same expression on both sides of '=='.
CWE459_Incomplete_Cleanup	Same expression on both sides of '!='.
CWE459_Incomplete_Cleanup	The scope of the variable 'pFile' can be reduced.
CWE464_Addition_of_Data_Structure_Sentinel	Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).
CWE464_Addition_of_Data_Structure_Sentinel	Condition '5!=5' is always false
CWE464_Addition_of_Data_Structure_Sentinel	Condition '5==5' is always true
CWE464_Addition_of_Data_Structure_Sentinel	Same expression on both sides of '=='.
CWE464_Addition_of_Data_Structure_Sentinel	Same expression on both sides of '!='.
CWE464_Addition_of_Data_Structure_Sentinel	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE464_Addition_of_Data_Structure_Sentinel	The scope of the variable 'dataRef' can be reduced.
CWE464_Addition_of_Data_Structure_Sentinel	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE464_Addition_of_Data_Structure_Sentinel	Value stored to 'data' during its initialization is never read
CWE464_Addition_of_Data_Structure_Sentinel	Value stored to 'data' is never read
CWE464_Addition_of_Data_Structure_Sentinel	Variable 'data' is assigned a value that is never used.
CWE464_Addition_of_Data_Structure_Sentinel	Variable 'data' is reassigned a value before the old one has been used.
CWE467_Use_of_sizeof_on_Pointer_Type	Condition '5!=5' is always false
CWE467_Use_of_sizeof_on_Pointer_Type	Condition '5==5' is always true
CWE467_Use_of_sizeof_on_Pointer_Type	out of bounds write. assert \valid(badChar);
CWE467_Use_of_sizeof_on_Pointer_Type	out of bounds write. assert \valid(badInt);
CWE467_Use_of_sizeof_on_Pointer_Type	out of bounds write. assert \valid(badShort);
CWE467_Use_of_sizeof_on_Pointer_Type	out of bounds write. assert \valid(goodChar);
CWE467_Use_of_sizeof_on_Pointer_Type	out of bounds write. assert \valid(goodChar_0);
CWE467_Use_of_sizeof_on_Pointer_Type	out of bounds write. assert \valid(goodInt);
CWE467_Use_of_sizeof_on_Pointer_Type	out of bounds write. assert \valid(goodInt_0);
CWE467_Use_of_sizeof_on_Pointer_Type	out of bounds write. assert \valid(goodShort);
CWE467_Use_of_sizeof_on_Pointer_Type	out of bounds write. assert \valid(goodShort_0);
CWE467_Use_of_sizeof_on_Pointer_Type	Result of 'malloc' is converted to a pointer of type 'char', which is incompatible with sizeof operand type 'char *'
CWE467_Use_of_sizeof_on_Pointer_Type	Result of 'malloc' is converted to a pointer of type 'int', which is incompatible with sizeof operand type 'int *'
CWE467_Use_of_sizeof_on_Pointer_Type	Result of 'malloc' is converted to a pointer of type 'short', which is incompatible with sizeof operand type 'short *'
CWE467_Use_of_sizeof_on_Pointer_Type	Same expression on both sides of '=='.
CWE467_Use_of_sizeof_on_Pointer_Type	Same expression on both sides of '!='.
CWE467_Use_of_sizeof_on_Pointer_Type	Size of pointer 'badChar' used instead of size of its data.
CWE467_Use_of_sizeof_on_Pointer_Type	Size of pointer 'badInt' used instead of size of its data.
CWE467_Use_of_sizeof_on_Pointer_Type	Size of pointer 'badShort' used instead of size of its data.
CWE468_Incorrect_Pointer_Scaling	Assigned value is garbage or undefined
CWE468_Incorrect_Pointer_Scaling	Condition '5!=5' is always false
CWE468_Incorrect_Pointer_Scaling	Condition '5==5' is always true
CWE468_Incorrect_Pointer_Scaling	Same expression on both sides of '=='.
CWE468_Incorrect_Pointer_Scaling	Same expression on both sides of '!='.
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	Condition '5!=5' is always false
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	Condition '5==5' is always true
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	pointer comparison.
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	pointer subtraction.
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	Same expression on both sides of '=='.
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	Same expression on both sides of '!='.
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	signed overflow. assert -2147483648 ≤ slashInString1_0 - (char *)string1_0;
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	signed overflow. assert -2147483648 ≤ slashInString1 - (char *)string1;
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	signed overflow. assert slashInString1_0 - (char *)string1_0 ≤ 2147483647;
CWE469_Use_of_Pointer_Subtraction_to_Determine_Size	signed overflow. assert slashInString1 - (char *)string1 ≤ 2147483647;
CWE475_Undefined_Behavior_for_Input_to_API	Condition '5!=5' is always false
CWE475_Undefined_Behavior_for_Input_to_API	Condition '5==5' is always true
CWE475_Undefined_Behavior_for_Input_to_API	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused). Risk is low because the source is a constant string.
CWE475_Undefined_Behavior_for_Input_to_API	Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
CWE475_Undefined_Behavior_for_Input_to_API	Same expression on both sides of '=='.
CWE475_Undefined_Behavior_for_Input_to_API	Same expression on both sides of '!='.
CWE475_Undefined_Behavior_for_Input_to_API	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE476_NULL_Pointer_Dereference	accessing left-value that contains escaping addresses.
CWE476_NULL_Pointer_Dereference	accessing uninitialized left-value. assert \initialized(&data);
CWE476_NULL_Pointer_Dereference	accessing uninitialized left-value. assert \initialized(dataPtr1);
CWE476_NULL_Pointer_Dereference	Access to field 'intOne' results in a dereference of a null pointer (loaded from variable 'data')
CWE476_NULL_Pointer_Dereference	Access to field 'intOne' results in a dereference of a null pointer (loaded from variable 'twoIntsStructPointer')
CWE476_NULL_Pointer_Dereference	Array access (from variable 'data') results in a null pointer dereference
CWE476_NULL_Pointer_Dereference	Assigned value is garbage or undefined
CWE476_NULL_Pointer_Dereference	Condition '5!=5' is always false
CWE476_NULL_Pointer_Dereference	Condition '5==5' is always true
CWE476_NULL_Pointer_Dereference	Condition 'data!=NULL' is always false
CWE476_NULL_Pointer_Dereference	Condition 'intPointer==NULL' is always true
CWE476_NULL_Pointer_Dereference	Condition 'twoIntsStructPointer!=NULL' is always false
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE476_NULL_Pointer_Dereference	Dereference of null pointer (loaded from variable 'data')
CWE476_NULL_Pointer_Dereference	Dereference of null pointer (loaded from variable 'intPointer')
CWE476_NULL_Pointer_Dereference	Dereference of undefined pointer value
CWE476_NULL_Pointer_Dereference	Either the condition 'intPointer!=NULL' is redundant or there is possible null pointer dereference: intPointer.
CWE476_NULL_Pointer_Dereference	locals {tmpData_0} escaping the scope of a block of goodG2B through data
CWE476_NULL_Pointer_Dereference	locals {tmpData} escaping the scope of a block of goodG2B1 through data
CWE476_NULL_Pointer_Dereference	locals {tmpData} escaping the scope of a block of goodG2B through data
CWE476_NULL_Pointer_Dereference	Null pointer dereference: data
CWE476_NULL_Pointer_Dereference	Null pointer dereference: intPointer
CWE476_NULL_Pointer_Dereference	Null pointer dereference: twoIntsStructPointer
CWE476_NULL_Pointer_Dereference	out of bounds read. assert \valid_read(data + 0);
CWE476_NULL_Pointer_Dereference	out of bounds read. assert \valid_read(data_0 + 0);
CWE476_NULL_Pointer_Dereference	out of bounds read. assert \valid_read(intPointer);
CWE476_NULL_Pointer_Dereference	out of bounds read. assert \valid_read(&twoIntsStructPointer->intOne);
CWE476_NULL_Pointer_Dereference	out of bounds write. assert \valid(intPointer);
CWE476_NULL_Pointer_Dereference	out of bounds write. assert \valid(intPointer_0);
CWE476_NULL_Pointer_Dereference	Possible null pointer dereference: data
CWE476_NULL_Pointer_Dereference	Potential leak of memory pointed to by 'data'
CWE476_NULL_Pointer_Dereference	Potential leak of memory pointed to by 'intPointer'
CWE476_NULL_Pointer_Dereference	Potential leak of memory pointed to by 'myUnion.unionFirst'
CWE476_NULL_Pointer_Dereference	Same expression on both sides of '=='.
CWE476_NULL_Pointer_Dereference	Same expression on both sides of '!='.
CWE476_NULL_Pointer_Dereference	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE476_NULL_Pointer_Dereference	The left operand of '!=' is a garbage value
CWE476_NULL_Pointer_Dereference	Value stored to 'data' during its initialization is never read
CWE476_NULL_Pointer_Dereference	Value stored to 'data' is never read
CWE476_NULL_Pointer_Dereference	Variable 'data' is not assigned a value.
CWE476_NULL_Pointer_Dereference	Variable 'data' is reassigned a value before the old one has been used.
CWE476_NULL_Pointer_Dereference	Variable 'intPointer' is reassigned a value before the old one has been used.
CWE476_NULL_Pointer_Dereference	Variable 'tmpData->intOne' is reassigned a value before the old one has been used.
CWE476_NULL_Pointer_Dereference	Variable 'tmpData' is assigned a value that is never used.
CWE478_Missing_Default_Case_in_Switch	Condition '5!=5' is always false
CWE478_Missing_Default_Case_in_Switch	Condition '5==5' is always true
CWE478_Missing_Default_Case_in_Switch	Same expression on both sides of '=='.
CWE478_Missing_Default_Case_in_Switch	Same expression on both sides of '!='.
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function	Condition '5!=5' is always false
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function	Condition '5==5' is always true
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function	Same expression on both sides of '=='.
CWE479_Signal_Handler_Use_of_Non_Reentrant_Function	Same expression on both sides of '!='.
CWE480_Use_of_Incorrect_Operator	Condition '5!=5' is always false
CWE480_Use_of_Incorrect_Operator	Condition '5==5' is always true
CWE480_Use_of_Incorrect_Operator	Same expression on both sides of '=='.
CWE480_Use_of_Incorrect_Operator	Same expression on both sides of '!='.
CWE481_Assigning_Instead_of_Comparing	Condition '5!=5' is always false
CWE481_Assigning_Instead_of_Comparing	Condition '5==5' is always true
CWE481_Assigning_Instead_of_Comparing	Same expression on both sides of '=='.
CWE481_Assigning_Instead_of_Comparing	Same expression on both sides of '!='.
CWE481_Assigning_Instead_of_Comparing	Value stored to 'intRand' during its initialization is never read
CWE482_Comparing_Instead_of_Assigning	Condition '5!=5' is always false
CWE482_Comparing_Instead_of_Assigning	Condition '5==5' is always true
CWE482_Comparing_Instead_of_Assigning	Same expression on both sides of '=='.
CWE482_Comparing_Instead_of_Assigning	Same expression on both sides of '!='.
CWE483_Incorrect_Block_Delimitation	Condition '5!=5' is always false
CWE483_Incorrect_Block_Delimitation	Condition '5==5' is always true
CWE483_Incorrect_Block_Delimitation	Same expression on both sides of '=='.
CWE483_Incorrect_Block_Delimitation	Same expression on both sides of '!='.
CWE483_Incorrect_Block_Delimitation	Value stored to 'y' is never read
CWE484_Omitted_Break_Statement_in_Switch	Condition '5!=5' is always false
CWE484_Omitted_Break_Statement_in_Switch	Condition '5==5' is always true
CWE484_Omitted_Break_Statement_in_Switch	Same expression on both sides of '=='.
CWE484_Omitted_Break_Statement_in_Switch	Same expression on both sides of '!='.
CWE506_Embedded_Malicious_Code	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE506_Embedded_Malicious_Code	Completely invalid destination for assigns
CWE506_Embedded_Malicious_Code	Condition '5==5' is always true
CWE506_Embedded_Malicious_Code	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE506_Embedded_Malicious_Code	Neither code nor specification for function connect, generating default assigns from the prototype
CWE506_Embedded_Malicious_Code	Neither code nor specification for function send, generating default assigns from the prototype
CWE506_Embedded_Malicious_Code	Same expression on both sides of '=='.
CWE506_Embedded_Malicious_Code	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE510_Trapdoor	Completely invalid destination for assigns
CWE510_Trapdoor	Condition '5!=5' is always false
CWE510_Trapdoor	Condition '5==5' is always true
CWE510_Trapdoor	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE510_Trapdoor	Neither code nor specification for function connect, generating default assigns from the prototype
CWE510_Trapdoor	Neither code nor specification for function getsockname, generating default assigns from the prototype
CWE510_Trapdoor	Neither code nor specification for function send, generating default assigns from the prototype
CWE510_Trapdoor	Same expression on both sides of '=='.
CWE510_Trapdoor	Same expression on both sides of '!='.
CWE510_Trapdoor	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE511_Logic_Time_Bomb	Condition '1==1' is always true
CWE511_Logic_Time_Bomb	Condition '5!=5' is always false
CWE511_Logic_Time_Bomb	Condition '5==5' is always true
CWE511_Logic_Time_Bomb	Neither code nor specification for function unlink, generating default assigns from the prototype
CWE511_Logic_Time_Bomb	Same expression on both sides of '=='.
CWE511_Logic_Time_Bomb	Same expression on both sides of '!='.
CWE511_Logic_Time_Bomb	signed overflow. assert count_0 + 1 ≤ 2147483647;
CWE511_Logic_Time_Bomb	signed overflow. assert count + 1 ≤ 2147483647;
CWE511_Logic_Time_Bomb	This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327). use a more secure technique for acquiring random values.
CWE526_Info_Exposure_Environment_Variables	Condition '5!=5' is always false
CWE526_Info_Exposure_Environment_Variables	Condition '5==5' is always true
CWE526_Info_Exposure_Environment_Variables	Environment variables are untrustable input if they can be set by an attacker. They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20). Check environment variables carefully before using them.
CWE526_Info_Exposure_Environment_Variables	Same expression on both sides of '=='.
CWE526_Info_Exposure_Environment_Variables	Same expression on both sides of '!='.
CWE546_Suspicious_Comment	Condition '5!=5' is always false
CWE546_Suspicious_Comment	Condition '5==5' is always true
CWE546_Suspicious_Comment	Same expression on both sides of '=='.
CWE546_Suspicious_Comment	Same expression on both sides of '!='.
CWE562_Return_of_Stack_Variable_Address	accessing left-value that contains escaping addresses.
CWE563_Unused_Variable	accessing uninitialized left-value. assert \initialized(&data);
CWE563_Unused_Variable	Assigned value is garbage or undefined
CWE563_Unused_Variable	Condition '5!=5' is always false
CWE563_Unused_Variable	Condition '5==5' is always true
CWE563_Unused_Variable	Function call argument is an uninitialized value
CWE563_Unused_Variable	Passed-by-value struct argument contains uninitialized data (e.g., field: 'intOne')
CWE563_Unused_Variable	Same expression on both sides of '=='.
CWE563_Unused_Variable	Same expression on both sides of '!='.
CWE563_Unused_Variable	The scope of the variable 'data' can be reduced.
CWE563_Unused_Variable	The scope of the variable 'dataRef' can be reduced.
CWE563_Unused_Variable	Uninitialized variable: data
CWE563_Unused_Variable	Unused variable: data
CWE563_Unused_Variable	Value stored to 'data' during its initialization is never read
CWE563_Unused_Variable	Value stored to 'data' is never read
CWE563_Unused_Variable	Variable 'data' is assigned a value that is never used.
CWE563_Unused_Variable	Variable 'data' is not assigned a value.
CWE563_Unused_Variable	Variable 'data' is reassigned a value before the old one has been used.
CWE570_Expression_Always_False	accessing out of bounds index. assert (int)(charStringLen - 1) < 10;
CWE570_Expression_Always_False	Checking if unsigned variable 'uIntBad' is less than zero.
CWE570_Expression_Always_False	Condition '2==3' is always false
CWE570_Expression_Always_False	Condition 'intThirty==(intThirty-1)' is always false
CWE570_Expression_Always_False	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE570_Expression_Always_False	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE570_Expression_Always_False	Unnecessary comparison of static strings.
CWE571_Expression_Always_True	accessing out of bounds index. assert (int)(charStringLen - 1) < 10;
CWE571_Expression_Always_True	Condition '2==2' is always true
CWE571_Expression_Always_True	Condition 'intRand1==(intRand2-1)' is always true
CWE571_Expression_Always_True	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE571_Expression_Always_True	Same expression on both sides of '=='.
CWE571_Expression_Always_True	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE571_Expression_Always_True	Unnecessary comparison of static strings.
CWE571_Expression_Always_True	Unsigned variable 'uIntBad' can't be negative so it is unnecessary to test it.
CWE587_Assignment_of_Fixed_Address_to_Pointer	Condition '5!=5' is always false
CWE587_Assignment_of_Fixed_Address_to_Pointer	Condition '5==5' is always true
CWE587_Assignment_of_Fixed_Address_to_Pointer	out of bounds read. assert \valid_read(charPointer);
CWE587_Assignment_of_Fixed_Address_to_Pointer	Same expression on both sides of '=='.
CWE587_Assignment_of_Fixed_Address_to_Pointer	Same expression on both sides of '!='.
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	accessing uninitialized left-value. assert \initialized(&data);
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	accessing uninitialized left-value. assert \initialized(dataPtr1);
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Assigned value is garbage or undefined
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Condition '5!=5' is always false
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Condition '5==5' is always true
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Dereference of undefined pointer value
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Function call argument is an uninitialized value
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_45_goodG2BData
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	locals {dataGoodBuffer} escaping the scope of goodG2B through CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer__struct_68_goodG2BData
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Same expression on both sides of '=='.
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Same expression on both sides of '!='.
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Uninitialized variable: data
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Value stored to 'data' during its initialization is never read
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Value stored to 'data' is never read
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Variable 'dataBadBuffer' is assigned a value that is never used.
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Variable 'data' is assigned a value that is never used.
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Variable 'data' is not assigned a value.
CWE588_Attempt_to_Access_Child_of_Non_Structure_Pointer	Variable 'data' is reassigned a value before the old one has been used.
CWE590_Free_Memory_Not_on_Heap	accessing left-value that contains escaping addresses.
CWE590_Free_Memory_Not_on_Heap	Access to field 'intOne' results in a dereference of a null pointer (loaded from variable 'data')
CWE590_Free_Memory_Not_on_Heap	all target addresses were invalid. This path is assumed to be dead.
CWE590_Free_Memory_Not_on_Heap	Argument to 'delete' is the address of the local variable 'buffer', which is not memory allocated by 'new'
CWE590_Free_Memory_Not_on_Heap	Argument to 'delete' is the address of the local variable 'dataBuffer', which is not memory allocated by 'new'
CWE590_Free_Memory_Not_on_Heap	Argument to 'delete[]' is the address of the local variable 'dataBuffer', which is not memory allocated by 'new[]'
CWE590_Free_Memory_Not_on_Heap	Argument to 'delete' is the address of the static variable 'dataBuffer', which is not memory allocated by 'new'
CWE590_Free_Memory_Not_on_Heap	Argument to 'delete[]' is the address of the static variable 'dataBuffer', which is not memory allocated by 'new[]'
CWE590_Free_Memory_Not_on_Heap	Argument to free() is the address of the local variable 'dataBuffer', which is not memory allocated by malloc()
CWE590_Free_Memory_Not_on_Heap	Argument to free() is the address of the static variable 'dataBuffer', which is not memory allocated by malloc()
CWE590_Free_Memory_Not_on_Heap	Array access (from variable 'data') results in a null pointer dereference
CWE590_Free_Memory_Not_on_Heap	Calling undeclared function alloca. Old style K&R code?
CWE590_Free_Memory_Not_on_Heap	Condition '5!=5' is always false
CWE590_Free_Memory_Not_on_Heap	Condition '5==5' is always true
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE590_Free_Memory_Not_on_Heap	Deallocation of an auto-variable results in undefined behaviour.
CWE590_Free_Memory_Not_on_Heap	Dereference of null pointer
CWE590_Free_Memory_Not_on_Heap	Dereference of null pointer (loaded from variable 'data')
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_01_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_02_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_03_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_04_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_05_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_06_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_07_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_08_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_09_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_10_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_11_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_12_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_13_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_14_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_15_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_16_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_17_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_18_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_31_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_32_bad through data_0
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_34_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_41_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_44_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_45_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_51_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_52_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_53_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_54_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_63_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_64_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_65_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_66_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_67_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_char_declare_68_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_01_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_02_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_03_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_04_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_05_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_06_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_07_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_08_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_09_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_10_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_11_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_12_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_13_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_14_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_15_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_16_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_17_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_18_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_31_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_32_bad through data_0
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_34_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_41_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_44_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_45_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_51_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_52_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_53_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_54_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_63_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_64_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_65_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_66_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_67_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_68_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_01_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_02_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_03_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_04_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_05_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_06_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_07_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_08_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_09_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_10_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_11_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_12_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_13_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_14_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_15_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_16_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_17_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_18_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_31_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_32_bad through data_0
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_34_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_41_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_44_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_45_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_51_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_52_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_53_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_54_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_63_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_64_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_65_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_66_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_67_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_int_declare_68_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_01_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_02_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_03_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_04_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_05_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_06_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_07_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_08_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_09_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_10_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_11_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_12_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_13_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_14_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_15_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_16_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_17_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_18_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_31_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_32_bad through data_0
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_34_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_41_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_44_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_45_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_51_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_52_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_53_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_54_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_63_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_64_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_65_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_66_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_67_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_long_declare_68_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_01_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_02_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_03_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_04_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_05_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_06_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_07_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_08_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_09_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_10_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_11_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_12_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_13_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_14_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_15_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_16_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_17_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_18_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_31_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_32_bad through data_0
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_34_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_41_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_44_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_45_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_51_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_52_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_53_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_54_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_63_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_64_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_65_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_66_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_67_bad through data
CWE590_Free_Memory_Not_on_Heap	locals {dataBuffer} escaping the scope of a block of CWE590_Free_Memory_Not_on_Heap__free_struct_declare_68_bad through data
CWE590_Free_Memory_Not_on_Heap	Memory allocated by alloca() should not be deallocated
CWE590_Free_Memory_Not_on_Heap	Neither code nor specification for function alloca, generating default assigns from the prototype
CWE590_Free_Memory_Not_on_Heap	out of bounds read. assert \valid_read(data + 0);
CWE590_Free_Memory_Not_on_Heap	out of bounds read. assert \valid_read(data_0 + 0);
CWE590_Free_Memory_Not_on_Heap	out of bounds read. assert \valid_read(data_1 + 0);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(dataBuffer_0 + i);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(dataBuffer_0 + i_0);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(&(dataBuffer_0 + i_0)->intOne);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(&(dataBuffer_0 + i)->intOne);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(dataBuffer_0 + (int)(100 - 1));
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(dataBuffer_1 + i_0);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(&(dataBuffer_1 + i_0)->intOne);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(dataBuffer_1 + (int)(100 - 1));
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(dataBuffer + i);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(dataBuffer + i_0);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(&(dataBuffer + i_0)->intOne);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(&(dataBuffer + i)->intOne);
CWE590_Free_Memory_Not_on_Heap	out of bounds write. assert \valid(dataBuffer + (int)(100 - 1));
CWE590_Free_Memory_Not_on_Heap	Possible null pointer dereference: data
CWE590_Free_Memory_Not_on_Heap	Potential leak of memory pointed to by 'myUnion.unionFirst'
CWE590_Free_Memory_Not_on_Heap	Same expression on both sides of '=='.
CWE590_Free_Memory_Not_on_Heap	Same expression on both sides of '!='.
CWE590_Free_Memory_Not_on_Heap	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE590_Free_Memory_Not_on_Heap	Value stored to 'data' during its initialization is never read
CWE590_Free_Memory_Not_on_Heap	Value stored to 'data' is never read
CWE590_Free_Memory_Not_on_Heap	Variable 'dataBuffer' is assigned a value that is never used.
CWE590_Free_Memory_Not_on_Heap	Variable 'data' is assigned a value that is never used.
CWE605_Multiple_Binds_Same_Port	accessing out of bounds index. assert recvResult_0 < 100;
CWE605_Multiple_Binds_Same_Port	accessing out of bounds index. assert recvResult < 100;
CWE605_Multiple_Binds_Same_Port	Completely invalid destination for assigns
CWE605_Multiple_Binds_Same_Port	Condition '5!=5' is always false
CWE605_Multiple_Binds_Same_Port	Condition '5==5' is always true
CWE605_Multiple_Binds_Same_Port	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE605_Multiple_Binds_Same_Port	out of bounds write. assert \valid(replace);
CWE605_Multiple_Binds_Same_Port	out of bounds write. assert \valid(replace_0);
CWE605_Multiple_Binds_Same_Port	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace);
CWE605_Multiple_Binds_Same_Port	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace_0);
CWE605_Multiple_Binds_Same_Port	Same expression on both sides of '=='.
CWE605_Multiple_Binds_Same_Port	Same expression on both sides of '!='.
CWE605_Multiple_Binds_Same_Port	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE605_Multiple_Binds_Same_Port	The scope of the variable 'recvResult' can be reduced.
CWE605_Multiple_Binds_Same_Port	The scope of the variable 'replace' can be reduced.
CWE606_Unchecked_Loop_Condition	accessing uninitialized left-value. assert \initialized(&n);
CWE606_Unchecked_Loop_Condition	accessing uninitialized left-value. assert \initialized(&n_0);
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_connect_socket_45_badData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_connect_socket_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_connect_socket_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_console_45_badData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_console_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_console_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_environment_45_badData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_environment_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_environment_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_file_45_badData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_file_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_file_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_listen_socket_45_badData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_listen_socket_45_goodB2GData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE606_Unchecked_Loop_Condition__char_listen_socket_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE606_Unchecked_Loop_Condition	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE606_Unchecked_Loop_Condition	Completely invalid destination for assigns
CWE606_Unchecked_Loop_Condition	Condition '5!=5' is always false
CWE606_Unchecked_Loop_Condition	Condition '5==5' is always true
CWE606_Unchecked_Loop_Condition	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused). Risk is low because the source is a constant string.
CWE606_Unchecked_Loop_Condition	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE606_Unchecked_Loop_Condition	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_connect_socket_45_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_connect_socket_68_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_console_45_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_console_68_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_environment_45_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_environment_68_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_file_45_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_file_68_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_listen_socket_45_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodB2G through CWE606_Unchecked_Loop_Condition__char_listen_socket_68_goodB2GData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_connect_socket_45_goodG2BData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_connect_socket_68_goodG2BData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_console_45_goodG2BData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_console_68_goodG2BData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_environment_45_goodG2BData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_environment_68_goodG2BData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_file_45_goodG2BData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_file_68_goodG2BData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_listen_socket_45_goodG2BData
CWE606_Unchecked_Loop_Condition	locals {dataBuffer} escaping the scope of goodG2B through CWE606_Unchecked_Loop_Condition__char_listen_socket_68_goodG2BData
CWE606_Unchecked_Loop_Condition	Neither code nor specification for function connect, generating default assigns from the prototype
CWE606_Unchecked_Loop_Condition	Neither code nor specification for function sscanf, generating default assigns from the prototype
CWE606_Unchecked_Loop_Condition	out of bounds read. assert \valid_read(data_0 + (unsigned int)(dataLen - 1));
CWE606_Unchecked_Loop_Condition	out of bounds read. assert \valid_read(data + (unsigned int)(dataLen_0 - 1));
CWE606_Unchecked_Loop_Condition	out of bounds read. assert \valid_read(data + (unsigned int)(dataLen - 1));
CWE606_Unchecked_Loop_Condition	out of bounds write.
CWE606_Unchecked_Loop_Condition	out of bounds write. assert \valid(data_0 + dataLen);
CWE606_Unchecked_Loop_Condition	out of bounds write. assert \valid(data + dataLen);
CWE606_Unchecked_Loop_Condition	out of bounds write. assert \valid(data + dataLen_0);
CWE606_Unchecked_Loop_Condition	out of bounds write. assert \valid(replace);
CWE606_Unchecked_Loop_Condition	out of bounds write. assert \valid(replace_0);
CWE606_Unchecked_Loop_Condition	pointer comparison.
CWE606_Unchecked_Loop_Condition	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace);
CWE606_Unchecked_Loop_Condition	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace_0);
CWE606_Unchecked_Loop_Condition	Same expression on both sides of '=='.
CWE606_Unchecked_Loop_Condition	Same expression on both sides of '!='.
CWE606_Unchecked_Loop_Condition	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE606_Unchecked_Loop_Condition	The scope of the variable 'i' can be reduced.
CWE606_Unchecked_Loop_Condition	The scope of the variable 'intVariable' can be reduced.
CWE606_Unchecked_Loop_Condition	The scope of the variable 'pFile' can be reduced.
CWE606_Unchecked_Loop_Condition	The scope of the variable 'recvResult' can be reduced.
CWE606_Unchecked_Loop_Condition	The scope of the variable 'replace' can be reduced.
CWE606_Unchecked_Loop_Condition	Variable 'dataBuffer' is assigned a value that is never used.
CWE606_Unchecked_Loop_Condition	Variable 'data' is assigned a value that is never used.
CWE617_Reachable_Assertion	Completely invalid destination for assigns
CWE617_Reachable_Assertion	Condition '5!=5' is always false
CWE617_Reachable_Assertion	Condition '5==5' is always true
CWE617_Reachable_Assertion	Neither code nor specification for function connect, generating default assigns from the prototype
CWE617_Reachable_Assertion	Same expression on both sides of '=='.
CWE617_Reachable_Assertion	Same expression on both sides of '!='.
CWE617_Reachable_Assertion	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE617_Reachable_Assertion	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE617_Reachable_Assertion	The scope of the variable 'dataRef' can be reduced.
CWE617_Reachable_Assertion	The scope of the variable 'recvResult' can be reduced.
CWE617_Reachable_Assertion	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE617_Reachable_Assertion	Value stored to 'data' during its initialization is never read
CWE617_Reachable_Assertion	Value stored to 'data' is never read
CWE617_Reachable_Assertion	Variable 'data' is assigned a value that is never used.
CWE617_Reachable_Assertion	Variable 'data' is reassigned a value before the old one has been used.
CWE665_Improper_Initialization	Condition '5!=5' is always false
CWE665_Improper_Initialization	Condition '5==5' is always true
CWE665_Improper_Initialization	Does not check for buffer overflows when concatenating to destination (CWE-120). Consider using strcat_s, strncat, or strlcat (warning, strncat is easily misused).
CWE665_Improper_Initialization	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE665_Improper_Initialization	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE665_Improper_Initialization	locals {dataBuffer} escaping the scope of goodG2B through CWE665_Improper_Initialization__char_cat_45_goodG2BData
CWE665_Improper_Initialization	locals {dataBuffer} escaping the scope of goodG2B through CWE665_Improper_Initialization__char_cat_68_goodG2BData
CWE665_Improper_Initialization	locals {dataBuffer} escaping the scope of goodG2B through CWE665_Improper_Initialization__char_ncat_45_goodG2BData
CWE665_Improper_Initialization	locals {dataBuffer} escaping the scope of goodG2B through CWE665_Improper_Initialization__char_ncat_68_goodG2BData
CWE665_Improper_Initialization	Same expression on both sides of '=='.
CWE665_Improper_Initialization	Same expression on both sides of '!='.
CWE665_Improper_Initialization	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE665_Improper_Initialization	Unused variable: dataBuffer
CWE665_Improper_Initialization	Value stored to 'data' is never read
CWE665_Improper_Initialization	Variable 'dataBuffer' is assigned a value that is never used.
CWE665_Improper_Initialization	Variable 'data' is assigned a value that is never used.
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	accessing out of bounds index. assert recvResult_0 < 100;
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	accessing out of bounds index. assert recvResult < 100;
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	Completely invalid destination for assigns
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	Condition '5!=5' is always false
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	Condition '5==5' is always true
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	out of bounds write. assert \valid(replace);
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	out of bounds write. assert \valid(replace_0);
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace);
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace_0);
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	Same expression on both sides of '=='.
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	Same expression on both sides of '!='.
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	The scope of the variable 'recvResult' can be reduced.
CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime	The scope of the variable 'replace' can be reduced.
CWE667_Improper_Locking	Completely invalid destination for assigns clause *lock. Ignoring.
CWE667_Improper_Locking	Condition '5!=5' is always false
CWE667_Improper_Locking	Condition '5==5' is always true
CWE667_Improper_Locking	Neither code nor specification for function stdThreadLockAcquire, generating default assigns from the prototype
CWE667_Improper_Locking	Neither code nor specification for function stdThreadLockCreate, generating default assigns from the prototype
CWE667_Improper_Locking	Neither code nor specification for function stdThreadLockDestroy, generating default assigns from the prototype
CWE667_Improper_Locking	Neither code nor specification for function stdThreadLockRelease, generating default assigns from the prototype
CWE667_Improper_Locking	Same expression on both sides of '=='.
CWE667_Improper_Locking	Same expression on both sides of '!='.
CWE672_Operation_on_Resource_After_Expiration_or_Release	Condition '5!=5' is always false
CWE672_Operation_on_Resource_After_Expiration_or_Release	Condition '5==5' is always true
CWE672_Operation_on_Resource_After_Expiration_or_Release	Function parameter 'dataCopy' should be passed by reference.
CWE672_Operation_on_Resource_After_Expiration_or_Release	Function parameter 'data' should be passed by reference.
CWE672_Operation_on_Resource_After_Expiration_or_Release	Prefer prefix ++/-- operators for non-primitive types.
CWE672_Operation_on_Resource_After_Expiration_or_Release	Same expression on both sides of '=='.
CWE672_Operation_on_Resource_After_Expiration_or_Release	Same expression on both sides of '!='.
CWE672_Operation_on_Resource_After_Expiration_or_Release	Variable 'data' is assigned in constructor body. Consider performing initialization in initialization list.
CWE675_Duplicate_Operations_on_Resource	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE675_Duplicate_Operations_on_Resource	Condition '5!=5' is always false
CWE675_Duplicate_Operations_on_Resource	Condition '5==5' is always true
CWE675_Duplicate_Operations_on_Resource	Deallocating a deallocated pointer: data
CWE675_Duplicate_Operations_on_Resource	Resource handle 'data' freed twice.
CWE675_Duplicate_Operations_on_Resource	Returning/dereferencing 'data' after it is deallocated / released
CWE675_Duplicate_Operations_on_Resource	Same expression on both sides of '=='.
CWE675_Duplicate_Operations_on_Resource	Same expression on both sides of '!='.
CWE675_Duplicate_Operations_on_Resource	The scope of the variable 'data' can be reduced.
CWE675_Duplicate_Operations_on_Resource	The scope of the variable 'dataRef' can be reduced.
CWE675_Duplicate_Operations_on_Resource	Used file that is not opened.
CWE675_Duplicate_Operations_on_Resource	Value stored to 'data' during its initialization is never read
CWE675_Duplicate_Operations_on_Resource	Value stored to 'data' is never read
CWE675_Duplicate_Operations_on_Resource	Variable 'data' is assigned a value that is never used.
CWE675_Duplicate_Operations_on_Resource	Variable 'data' is reassigned a value before the old one has been used.
CWE676_Use_of_Potentially_Dangerous_Function	Condition '5!=5' is always false
CWE676_Use_of_Potentially_Dangerous_Function	Condition '5==5' is always true
CWE676_Use_of_Potentially_Dangerous_Function	Same expression on both sides of '=='.
CWE676_Use_of_Potentially_Dangerous_Function	Same expression on both sides of '!='.
CWE676_Use_of_Potentially_Dangerous_Function	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE680_Integer_Overflow_to_Buffer_Overflow	Completely invalid destination for assigns
CWE680_Integer_Overflow_to_Buffer_Overflow	Condition '5!=5' is always false
CWE680_Integer_Overflow_to_Buffer_Overflow	Condition '5==5' is always true
CWE680_Integer_Overflow_to_Buffer_Overflow	Function call argument is an uninitialized value
CWE680_Integer_Overflow_to_Buffer_Overflow	Invalid malloc() argument nr 1. The value is -4 but the valid values are '0:'.
CWE680_Integer_Overflow_to_Buffer_Overflow	Memory allocation size is negative.
CWE680_Integer_Overflow_to_Buffer_Overflow	Neither code nor specification for function connect, generating default assigns from the prototype
CWE680_Integer_Overflow_to_Buffer_Overflow	out of bounds read. assert \valid_read(intPointer + 0);
CWE680_Integer_Overflow_to_Buffer_Overflow	out of bounds write. assert \valid(intPointer + i);
CWE680_Integer_Overflow_to_Buffer_Overflow	out of bounds write. assert \valid(intPointer + i_0);
CWE680_Integer_Overflow_to_Buffer_Overflow	Same expression on both sides of '=='.
CWE680_Integer_Overflow_to_Buffer_Overflow	Same expression on both sides of '!='.
CWE680_Integer_Overflow_to_Buffer_Overflow	signed overflow. assert tmp << 30 ≤ 2147483647;
CWE680_Integer_Overflow_to_Buffer_Overflow	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE680_Integer_Overflow_to_Buffer_Overflow	Suspicious code: sign conversion of data in calculation, even though data can have a negative value
CWE680_Integer_Overflow_to_Buffer_Overflow	The scope of the variable 'dataRef' can be reduced.
CWE680_Integer_Overflow_to_Buffer_Overflow	The scope of the variable 'recvResult' can be reduced.
CWE680_Integer_Overflow_to_Buffer_Overflow	Unless checked, the resulting number can exceed the expected range (CWE-190). If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).
CWE680_Integer_Overflow_to_Buffer_Overflow	Value stored to 'data' during its initialization is never read
CWE680_Integer_Overflow_to_Buffer_Overflow	Value stored to 'data' is never read
CWE680_Integer_Overflow_to_Buffer_Overflow	Variable 'data' is assigned a value that is never used.
CWE680_Integer_Overflow_to_Buffer_Overflow	Variable 'data' is reassigned a value before the old one has been used.
CWE681_Incorrect_Conversion_Between_Numeric_Types	Condition '5!=5' is always false
CWE681_Incorrect_Conversion_Between_Numeric_Types	Condition '5==5' is always true
CWE681_Incorrect_Conversion_Between_Numeric_Types	non-finite double value.
CWE681_Incorrect_Conversion_Between_Numeric_Types	non-finite double value. assert \is_finite(doubleNumber);
CWE681_Incorrect_Conversion_Between_Numeric_Types	non-finite double value. assert \is_finite(doubleNumber_0);
CWE681_Incorrect_Conversion_Between_Numeric_Types	non-finite float value. assert \is_finite((float)doubleNumber);
CWE681_Incorrect_Conversion_Between_Numeric_Types	overflow in conversion from floating-point to integer.
CWE681_Incorrect_Conversion_Between_Numeric_Types	Same expression on both sides of '=='.
CWE681_Incorrect_Conversion_Between_Numeric_Types	Same expression on both sides of '!='.
CWE681_Incorrect_Conversion_Between_Numeric_Types	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE685_Function_Call_With_Incorrect_Number_of_Arguments	Condition '5!=5' is always false
CWE685_Function_Call_With_Incorrect_Number_of_Arguments	Condition '5==5' is always true
CWE685_Function_Call_With_Incorrect_Number_of_Arguments	Does not check for buffer overflows (CWE-120). Use sprintf_s, snprintf, or vsnprintf.
CWE685_Function_Call_With_Incorrect_Number_of_Arguments	Same expression on both sides of '=='.
CWE685_Function_Call_With_Incorrect_Number_of_Arguments	Same expression on both sides of '!='.
CWE685_Function_Call_With_Incorrect_Number_of_Arguments	sprintf format string requires 2 parameters but only 1 is given.
CWE685_Function_Call_With_Incorrect_Number_of_Arguments	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument	Condition '5!=5' is always false
CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument	Condition '5==5' is always true
CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument	Does not check for buffer overflows (CWE-120). Use sprintf_s, snprintf, or vsnprintf.
CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument	Does not check for buffer overflows (CWE-120). Use sprintf_s, snprintf, or vsnprintf. Risk is low because the source has a constant maximum length.
CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument	Same expression on both sides of '=='.
CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument	Same expression on both sides of '!='.
CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument	%s in format string (no. 1) requires 'char *' but the argument type is 'signed int'.
CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE690_NULL_Deref_From_Return	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE690_NULL_Deref_From_Return	Common realloc mistake: 'data' nulled but not freed upon failure
CWE690_NULL_Deref_From_Return	Condition '5!=5' is always false
CWE690_NULL_Deref_From_Return	Condition '5==5' is always true
CWE690_NULL_Deref_From_Return	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused). Risk is low because the source is a constant string.
CWE690_NULL_Deref_From_Return	Memory leak: data
CWE690_NULL_Deref_From_Return	No code nor implicit assigns clause for function calloc, generating default assigns from the prototype
CWE690_NULL_Deref_From_Return	out of bounds write. assert \valid(data + 0);
CWE690_NULL_Deref_From_Return	out of bounds write. assert \valid(data_0 + 0);
CWE690_NULL_Deref_From_Return	out of bounds write. assert \valid(&(data_0 + 0)->intOne);
CWE690_NULL_Deref_From_Return	out of bounds write. assert \valid(&(data + 0)->intOne);
CWE690_NULL_Deref_From_Return	out of bounds write. assert \valid(data_1 + 0);
CWE690_NULL_Deref_From_Return	out of bounds write. assert \valid(&(data_1 + 0)->intOne);
CWE690_NULL_Deref_From_Return	Potential leak of memory pointed to by 'data'
CWE690_NULL_Deref_From_Return	Potential leak of memory pointed to by 'myUnion.unionFirst'
CWE690_NULL_Deref_From_Return	Resource leak: data
CWE690_NULL_Deref_From_Return	Same expression on both sides of '=='.
CWE690_NULL_Deref_From_Return	Same expression on both sides of '!='.
CWE690_NULL_Deref_From_Return	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE690_NULL_Deref_From_Return	Value stored to 'data' during its initialization is never read
CWE690_NULL_Deref_From_Return	Value stored to 'data' is never read
CWE690_NULL_Deref_From_Return	Variable 'data' is assigned a value that is never used.
CWE690_NULL_Deref_From_Return	Variable 'data' is reassigned a value before the old one has been used.
CWE758_Undefined_Behavior	all target addresses were invalid. This path is assumed to be dead.
CWE758_Undefined_Behavior	Assigned value is garbage or undefined
CWE758_Undefined_Behavior	Calling undeclared function alloca. Old style K&R code?
CWE758_Undefined_Behavior	Condition '5!=5' is always false
CWE758_Undefined_Behavior	Condition '5==5' is always true
CWE758_Undefined_Behavior	Function call argument is an uninitialized value
CWE758_Undefined_Behavior	Memory is allocated but not initialized: pointer
CWE758_Undefined_Behavior	Neither code nor specification for function alloca, generating default assigns from the prototype
CWE758_Undefined_Behavior	non-finite double value. assert \is_finite(*data);
CWE758_Undefined_Behavior	non-finite double value. assert \is_finite(*data_0);
CWE758_Undefined_Behavior	non-finite double value. assert \is_finite(*data_1);
CWE758_Undefined_Behavior	non-finite double value. assert \is_finite(*data_2);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(data);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(data_0);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(&data_0->intOne);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(&data_0->intTwo);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(data_1);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(&data_1->intOne);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(&data_1->intTwo);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(data_2);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(&data_2->intOne);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(&data_2->intTwo);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(&data->intOne);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(&data->intTwo);
CWE758_Undefined_Behavior	out of bounds read. assert \valid_read(pointer);
CWE758_Undefined_Behavior	out of bounds write. assert \valid(data);
CWE758_Undefined_Behavior	out of bounds write. assert \valid(data_0);
CWE758_Undefined_Behavior	out of bounds write. assert \valid(&data_0->intOne);
CWE758_Undefined_Behavior	out of bounds write. assert \valid(data_1);
CWE758_Undefined_Behavior	out of bounds write. assert \valid(&data_1->intOne);
CWE758_Undefined_Behavior	out of bounds write. assert \valid(&data->intOne);
CWE758_Undefined_Behavior	out of bounds write. assert \valid(pointer);
CWE758_Undefined_Behavior	out of bounds write. assert \valid(pointer_0);
CWE758_Undefined_Behavior	Potential leak of memory pointed to by 'data'
CWE758_Undefined_Behavior	Same expression on both sides of '=='.
CWE758_Undefined_Behavior	Same expression on both sides of '!='.
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Argument to free() is offset by 1 byte from the start of memory allocated by malloc()
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Argument to free() is offset by 2 bytes from the start of memory allocated by malloc()
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Argument to free() is offset by 3 bytes from the start of memory allocated by malloc()
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Completely invalid destination for assigns
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Condition '5!=5' is always false
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Condition '5==5' is always true
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused).
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Memory leak: data
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Neither code nor specification for function connect, generating default assigns from the prototype
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds read. assert \valid_read(data);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds read. assert \valid_read(data_0);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds read. assert \valid_read(data_0 + i);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds read. assert \valid_read(data_0 + (unsigned int)(dataLen - 1));
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds read. assert \valid_read(data_1);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds read. assert \valid_read(data_1 + i);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds read. assert \valid_read(data + i);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds read. assert \valid_read(data + i_0);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds read. assert \valid_read(data + (unsigned int)(dataLen - 1));
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds write.
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds write. assert \valid(data + 0);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds write. assert \valid(data_0 + dataLen);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds write. assert \valid(data_0 + (unsigned int)(dataLen - 1));
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds write. assert \valid(data + dataLen);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds write. assert \valid(data + (unsigned int)(dataLen - 1));
CWE761_Free_Pointer_Not_at_Start_of_Buffer	out of bounds write. assert \valid(replace);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	pointer comparison.
CWE761_Free_Pointer_Not_at_Start_of_Buffer	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	pointer comparison. assert \pointer_comparable((void *)dataLen, (void *)0);
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Potential leak of memory pointed to by 'data'
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Potential leak of memory pointed to by 'myUnion.unionFirst'
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Same expression on both sides of '=='.
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Same expression on both sides of '!='.
CWE761_Free_Pointer_Not_at_Start_of_Buffer	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE761_Free_Pointer_Not_at_Start_of_Buffer	The left operand of '==' is a garbage value
CWE761_Free_Pointer_Not_at_Start_of_Buffer	The scope of the variable 'pFile' can be reduced.
CWE761_Free_Pointer_Not_at_Start_of_Buffer	The scope of the variable 'recvResult' can be reduced.
CWE761_Free_Pointer_Not_at_Start_of_Buffer	The scope of the variable 'replace' can be reduced.
CWE762_Mismatched_Memory_Management_Routines	Condition '5!=5' is always false
CWE762_Mismatched_Memory_Management_Routines	Condition '5==5' is always true
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by calloc() should be deallocated by free(), not 'delete'
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by calloc() should be deallocated by free(), not 'delete[]'
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by malloc() should be deallocated by free(), not 'delete'
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by malloc() should be deallocated by free(), not 'delete[]'
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by 'new' should be deallocated by 'delete', not 'delete[]'
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by 'new[]' should be deallocated by 'delete[]', not 'delete'
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by 'new' should be deallocated by 'delete', not free()
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by 'new[]' should be deallocated by 'delete[]', not free()
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by realloc() should be deallocated by free(), not 'delete'
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by realloc() should be deallocated by free(), not 'delete[]'
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by strdup() should be deallocated by free(), not 'delete'
CWE762_Mismatched_Memory_Management_Routines	Memory allocated by strdup() should be deallocated by free(), not 'delete[]'
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_char_calloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_char_calloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_char_malloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_char_malloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_int64_t_calloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_int64_t_calloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_int64_t_malloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_int64_t_malloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_int_calloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_int_calloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_int_malloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_int_malloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_long_calloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_long_calloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_long_malloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_array_long_malloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_char_calloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_char_calloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_char_malloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_char_malloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_int64_t_calloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_int64_t_calloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_int64_t_malloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_int64_t_malloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_int_calloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_int_calloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_int_malloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_int_malloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_long_calloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_long_calloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_long_malloc_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__delete_long_malloc_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_delete_char_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_delete_char_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_delete_int64_t_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_delete_int64_t_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_delete_int_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_delete_int_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_delete_long_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_delete_long_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_free_char_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_free_char_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_free_int64_t_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_free_int64_t_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_free_int_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_free_int_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_free_long_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_array_free_long_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_delete_array_char_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_delete_array_char_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_delete_array_int64_t_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_delete_array_int64_t_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_delete_array_int_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_delete_array_int_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_delete_array_long_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_delete_array_long_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_free_char_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_free_char_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_free_int64_t_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_free_int64_t_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_free_int_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_free_int_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_free_long_83_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: CWE762_Mismatched_Memory_Management_Routines__new_free_long_84_bad::data
CWE762_Mismatched_Memory_Management_Routines	Mismatching allocation and deallocation: data
CWE762_Mismatched_Memory_Management_Routines	Potential leak of memory pointed to by 'data'
CWE762_Mismatched_Memory_Management_Routines	Potential leak of memory pointed to by 'myUnion.unionFirst'
CWE762_Mismatched_Memory_Management_Routines	Same expression on both sides of '=='.
CWE762_Mismatched_Memory_Management_Routines	Same expression on both sides of '!='.
CWE762_Mismatched_Memory_Management_Routines	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE762_Mismatched_Memory_Management_Routines	Value stored to 'data' during its initialization is never read
CWE762_Mismatched_Memory_Management_Routines	Value stored to 'data' is never read
CWE762_Mismatched_Memory_Management_Routines	Variable 'data' is assigned a value that is never used.
CWE762_Mismatched_Memory_Management_Routines	Variable 'data' is reassigned a value before the old one has been used.
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Condition '5!=5' is always false
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Condition '5==5' is always true
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Resource leak: data
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Same expression on both sides of '=='.
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Same expression on both sides of '!='.
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	The scope of the variable 'dataRef' can be reduced.
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Value stored to 'data' during its initialization is never read
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Value stored to 'data' is never read
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Variable 'data' is assigned a value that is never used.
CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle	Variable 'data' is reassigned a value before the old one has been used.
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Condition '5!=5' is always false
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Condition '5==5' is always true
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Resource leak: data
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Same expression on both sides of '=='.
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Same expression on both sides of '!='.
CWE775_Missing_Release_of_File_Descriptor_or_Handle	The scope of the variable 'dataRef' can be reduced.
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Value stored to 'data' during its initialization is never read
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Value stored to 'data' is never read
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Variable 'data' is assigned a value that is never used.
CWE775_Missing_Release_of_File_Descriptor_or_Handle	Variable 'data' is reassigned a value before the old one has been used.
CWE789_Uncontrolled_Mem_Alloc	Completely invalid destination for assigns
CWE789_Uncontrolled_Mem_Alloc	Completely invalid destination for assigns clause *endptr. Ignoring.
CWE789_Uncontrolled_Mem_Alloc	Condition '5!=5' is always false
CWE789_Uncontrolled_Mem_Alloc	Condition '5==5' is always true
CWE789_Uncontrolled_Mem_Alloc	Does not check for buffer overflows when copying to destination (CWE-120). Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused).
CWE789_Uncontrolled_Mem_Alloc	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE789_Uncontrolled_Mem_Alloc	Neither code nor specification for function connect, generating default assigns from the prototype
CWE789_Uncontrolled_Mem_Alloc	Same expression on both sides of '=='.
CWE789_Uncontrolled_Mem_Alloc	Same expression on both sides of '!='.
CWE789_Uncontrolled_Mem_Alloc	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE789_Uncontrolled_Mem_Alloc	The scope of the variable 'dataRef' can be reduced.
CWE789_Uncontrolled_Mem_Alloc	The scope of the variable 'myString' can be reduced.
CWE789_Uncontrolled_Mem_Alloc	The scope of the variable 'recvResult' can be reduced.
CWE789_Uncontrolled_Mem_Alloc	%u in format string (no. 1) requires 'unsigned int *' but the argument type is 'size_t * {aka unsigned long *}'.
CWE789_Uncontrolled_Mem_Alloc	Value stored to 'data' during its initialization is never read
CWE789_Uncontrolled_Mem_Alloc	Value stored to 'data' is never read
CWE789_Uncontrolled_Mem_Alloc	Variable 'data' is assigned a value that is never used.
CWE789_Uncontrolled_Mem_Alloc	Variable 'data' is reassigned a value before the old one has been used.
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_connect_socket_execl_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_connect_socket_execlp_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_connect_socket_execlp_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_console_execl_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_console_execl_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_console_execlp_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_console_execlp_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_environment_execl_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_environment_execl_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_environment_execlp_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_environment_execlp_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_file_execl_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_file_execl_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_file_execlp_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_file_execlp_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_listen_socket_execl_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_listen_socket_execlp_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'dataBuffer' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_listen_socket_execlp_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_connect_socket_popen_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_connect_socket_popen_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_connect_socket_system_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_connect_socket_system_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_console_popen_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_console_popen_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_console_system_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_console_system_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_environment_popen_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_environment_popen_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_environment_system_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_environment_system_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_file_popen_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_file_popen_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_file_system_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_file_system_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_listen_socket_popen_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_listen_socket_popen_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_listen_socket_system_45_badData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Address of stack memory associated with local variable 'data_buf' is still referred to by the global variable 'CWE78_OS_Command_Injection__char_listen_socket_system_45_goodG2BData' upon returning to the caller.  This will be a dangling reference
CWE78_OS_Command_Injection	Calling undeclared function pclose. Old style K&R code?
CWE78_OS_Command_Injection	Calling undeclared function popen. Old style K&R code?
CWE78_OS_Command_Injection	Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).
CWE78_OS_Command_Injection	Completely invalid destination for assigns
CWE78_OS_Command_Injection	Completely invalid destination for assigns clause *x_0. Ignoring.
CWE78_OS_Command_Injection	Condition '5!=5' is always false
CWE78_OS_Command_Injection	Condition '5==5' is always true
CWE78_OS_Command_Injection	Does not check for buffer overflows when concatenating to destination (CWE-120). Consider using strcat_s, strncat, or strlcat (warning, strncat is easily misused). Risk is low because the source is a constant string.
CWE78_OS_Command_Injection	Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).
CWE78_OS_Command_Injection	Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add) (CWE-120). Consider strcat_s, strlcat, or automatically resizing strings.
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_connect_socket_popen_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_connect_socket_popen_68_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_connect_socket_system_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_connect_socket_system_68_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_console_popen_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_console_popen_68_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_console_system_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_console_system_68_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_environment_popen_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_environment_popen_68_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_environment_system_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_environment_system_68_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_file_popen_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_file_popen_68_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_file_system_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_file_system_68_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_listen_socket_popen_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_listen_socket_popen_68_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_listen_socket_system_45_goodG2BData
CWE78_OS_Command_Injection	locals {data_buf} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_listen_socket_system_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_connect_socket_execl_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_connect_socket_execl_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_connect_socket_execlp_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_connect_socket_execlp_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_console_execl_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_console_execl_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_console_execlp_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_console_execlp_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_environment_execl_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_environment_execl_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_environment_execlp_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_environment_execlp_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_file_execl_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_file_execl_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_file_execlp_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_file_execlp_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_listen_socket_execl_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_listen_socket_execl_68_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_listen_socket_execlp_45_goodG2BData
CWE78_OS_Command_Injection	locals {dataBuffer} escaping the scope of goodG2B through CWE78_OS_Command_Injection__char_listen_socket_execlp_68_goodG2BData
CWE78_OS_Command_Injection	Neither code nor specification for function connect, generating default assigns from the prototype
CWE78_OS_Command_Injection	Neither code nor specification for function pclose, generating default assigns from the prototype
CWE78_OS_Command_Injection	Neither code nor specification for function popen, generating default assigns from the prototype
CWE78_OS_Command_Injection	out of bounds read. assert \valid_read(data_0 + (unsigned int)(dataLen - 1));
CWE78_OS_Command_Injection	out of bounds read. assert \valid_read(data + (unsigned int)(dataLen - 1));
CWE78_OS_Command_Injection	out of bounds write.
CWE78_OS_Command_Injection	out of bounds write. assert \valid(data_0 + dataLen);
CWE78_OS_Command_Injection	out of bounds write. assert \valid(data + dataLen);
CWE78_OS_Command_Injection	out of bounds write. assert \valid(replace);
CWE78_OS_Command_Injection	pointer comparison.
CWE78_OS_Command_Injection	pointer comparison. assert \pointer_comparable((void *)0, (void *)replace);
CWE78_OS_Command_Injection	Same expression on both sides of '=='.
CWE78_OS_Command_Injection	Same expression on both sides of '!='.
CWE78_OS_Command_Injection	Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
CWE78_OS_Command_Injection	The scope of the variable 'pFile' can be reduced.
CWE78_OS_Command_Injection	The scope of the variable 'recvResult' can be reduced.
CWE78_OS_Command_Injection	The scope of the variable 'replace' can be reduced.
CWE78_OS_Command_Injection	Variable 'dataBuffer' is assigned a value that is never used.
CWE78_OS_Command_Injection	Variable 'data_buf' is assigned a value that is never used.
CWE78_OS_Command_Injection	Variable 'data' is assigned a value that is never used.
CWE832_Unlock_of_Resource_That_is_Not_Locked	Completely invalid destination for assigns clause *lock. Ignoring.
CWE832_Unlock_of_Resource_That_is_Not_Locked	Condition '5!=5' is always false
CWE832_Unlock_of_Resource_That_is_Not_Locked	Condition '5==5' is always true
CWE832_Unlock_of_Resource_That_is_Not_Locked	Neither code nor specification for function stdThreadLockAcquire, generating default assigns from the prototype
CWE832_Unlock_of_Resource_That_is_Not_Locked	Neither code nor specification for function stdThreadLockCreate, generating default assigns from the prototype
CWE832_Unlock_of_Resource_That_is_Not_Locked	Neither code nor specification for function stdThreadLockDestroy, generating default assigns from the prototype
CWE832_Unlock_of_Resource_That_is_Not_Locked	Neither code nor specification for function stdThreadLockRelease, generating default assigns from the prototype
CWE832_Unlock_of_Resource_That_is_Not_Locked	Same expression on both sides of '=='.
CWE832_Unlock_of_Resource_That_is_Not_Locked	Same expression on both sides of '!='.
CWE835_Infinite_Loop	signed overflow. assert i + 1 ≤ 2147483647;
CWE843_Type_Confusion	accessing left-value that contains escaping addresses.
CWE843_Type_Confusion	Condition '5!=5' is always false
CWE843_Type_Confusion	Condition '5==5' is always true
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dead pointer usage. Pointer X is dead if it has assigned X at line X.
CWE843_Type_Confusion	Dereference of null pointer
CWE843_Type_Confusion	locals {intBuffer_0} escaping the scope of a block of goodG2B through data
CWE843_Type_Confusion	locals {intBuffer} escaping the scope of a block of goodG2B1 through data
CWE843_Type_Confusion	locals {intBuffer} escaping the scope of a block of goodG2B through data
CWE843_Type_Confusion	locals {intBuffer} escaping the scope of a block of goodG2B through data_0
CWE843_Type_Confusion	out of bounds read. assert \valid_read((int *)data);
CWE843_Type_Confusion	Possible null pointer dereference: data
CWE843_Type_Confusion	Same expression on both sides of '=='.
CWE843_Type_Confusion	Same expression on both sides of '!='.
CWE843_Type_Confusion	Value stored to 'data' during its initialization is never read
CWE843_Type_Confusion	Value stored to 'data' is never read
CWE843_Type_Confusion	Variable 'charBuffer' is assigned a value that is never used.
CWE843_Type_Confusion	Variable 'data' is assigned a value that is never used.
CWE843_Type_Confusion	Variable 'intBuffer' is assigned a value that is never used.
CWE843_Type_Confusion	Variable 'shortBuffer' is assigned a value that is never used.
